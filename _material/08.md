---
title: 8. Verkkoalgoritmit
slug: osa8
---

# 8. Verkkoalgoritmit

_Verkko_ (_graph_) on tietorakenne, joka muodostuu _solmuista_ (_node_) ja _kaarista_ (_edge_). Esimerkiksi seuraavassa verkossa on X solmua ja Y kaarta:

TODO

Verkkojen avulla voidaan mallintaa 

* tieverkko: solmut ovat kaupunkeja ja kaaret ovat teitä
* kontaktiverkko: solmut ovat ihmisiä ja kaaret ovat kontakteja
* tietoverkko: solmut ovat tietokoneita ja kaaret ovat yhteyksiä

## Verkot ohjelmoinnissa

Tavallinen tapa käsitellä verkkoa ohjelmoinnissa on pitää muistissa kunkin solmun _vieruslistaa_ (_adjacency list_). Solmun $$x$$ vieruslista sisältää kaikki solmut, jotka ovat yhteydessä solmuun $$x$$ kaarella.

Pythonissa voimme tallentaa verkon sanakirjana, jossa avaimet ovat solmuja ja arvot vieruslistoja. Esimerkkiverkko voidaan tallentaa seuraavasti:

```python
graph = {
    1: [2, 3, 4],
    2: [1, 4, 5],
    3: [1, 4],
    4: [1, 2, 3, 5],
    5: [2, 4]
}
```

Usein on kätevää tallentaa verkko luokan sisään niin, että verkossa on alussa vain solmut eikä kaaria. Luokassa on metodi, jonka avulla voidaan lisätä kaaria verkkoon. Luokka voidaan toteuttaa seuraavasti:

```python
class Graph:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}
        
    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)
```

Tässä konstruktorissa annetaan solmujen määrä `n`. Tämän perusteella luodaan sanakirja `edges`, joka sisältää vieruslistat. Aluksi jokainen vieruslista on tyhjä, ja metodi `add_edge` lisää kaaren solmujen `a` ja `b` välille.

Nyt voimme luoda esimerkkiverkon näin:

```python
g = Graph(5)

g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 4)
g.add_edge(2, 5)
g.add_edge(3, 4)
g.add_edge(4, 5)
```

## Syvyyshaku

_Syvyyshaku_ (_depth-first search_) eli _DFS_ on menetelmä, jonka avulla voidaan käydä läpi kaikki solmut, joihin pääsee lähtösolmusta kaaria pitkin.

```python
class DFS:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}
        
    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)
        
    def visit(self, node):
        if node in self.visited:
            return
        self.visited.add(node)

        for next_node in self.edges[node]:
            self.visit(next_node)
        
    def search(self, start_node):
        self.visited = set()
        self.visit(start_node)
```

```python
d = DFS(5)

d.add_edge(1, 2)
d.add_edge(1, 3)
d.add_edge(1, 4)
d.add_edge(2, 4)
d.add_edge(2, 5)
d.add_edge(3, 4)
d.add_edge(4, 5)

d.search(1)
print(g.visited) # {1, 2, 3, 4, 5}
```

### Komponentit ja yhtenäisyys

Verkon _komponentti_ (_component_) sisältää solmut, jotka ovat yhteydessä toisiinsa kaaria pitkin. Esimerkiksi seuraavassa verkossa komponentit ovat X, Y ja Z.

Verkko on _yhtenäinen_ (_connected_), jos siinä on tasan yksi komponentti eli minkä tahansa kahden solmun välillä on reitti kaaria pitkin.

Esimerkiksi tieverkossa komponentti sisältää kaupungit, joiden välillä pystyy kulkemaan teitä pitkin. Tieverkko on yhtenäinen, jos minkä tahansa kahden kaupungin välillä on olemassa reitti teitä pitkin.

Syvyyshaun avulla voidaan etsiä verkon komponentit käymällä läpi verkon solmut ja aloittamalla uusi haku aina, kun vastaan tulee solmu, joka ei ole vielä missään komponentissa. Seuraava luokka `Components` toteuttaa etsinnän:

```python
class Components:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}
        
    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)
        
    def visit(self, node):
        if node in self.components:
            return
        self.components[node] = self.counter

        for next_node in self.edges[node]:
            self.visit(next_node)
        
    def find_components(self):
        self.counter = 0
        self.components = {}

        for node in range(1, self.n + 1):
            if node not in self.components:
                self.counter += 1
                self.visit(node)
```

Muuttujassa `self.counter` on komponenttien määrä. Aina kun vastaan tulee solmu, joka ei ole vielä missään komponentissa, muuttujan arvo kasvaa yhdellä. Sanakirja `self.components` kertoo kunkin solmun komponentin.

Luokkaa voidaan käyttää seuraavasti:

```python
c = Components(5)

c.add_edge(1, 2)
c.add_edge(3, 4)
c.add_edge(4, 5)

c.find_components()

print(c.counter) # 2
print(c.components) # {1: 1, 2: 1, 3: 2, 4: 2, 5: 2}
```

Tässä tapauksessa verkossa on kaksi komponenttia. Ensimmäinen komponentti sisältää solmut 1 ja 2, ja toinen komponentti sisältää solmut 3, 4 ja 5.

## Leveyshaku

```python
class BFS:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}

    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)

    def search(self, start_node):
        self.visited = set()

        self.visited.add(start_node)
        queue = [start_node]

        for node in queue:
            for next_node in self.edges[node]:
                if next_node not in self.visited:
                    self.visited.add(next_node)
                    queue.append(next_node)
```

```python
b = BFS(5)

b.add_edge(1, 2)
b.add_edge(1, 3)
b.add_edge(1, 4)
b.add_edge(2, 4)
b.add_edge(2, 5)
b.add_edge(3, 4)
b.add_edge(4, 5)

b.search(1)
print(b.visited) # {1, 2, 3, 4, 5}
```

### Lyhimmät polut

Leveyshaun tavallinen käyttötarkoitus on etsiä _lyhin polku_ (_shortest path_) kahden solmun välillä. Tämä tarkoittaa reittiä, jossa kaarten määrä on mahdollisimman pieni. Kahden solmun _etäisyys_ (_distance_) on niiden välisen lyhimmän polun pituus.

Seuraava luokka etsii lyhimmät polut lähtösolmusta alkaen:

```python
class ShortestPaths:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}

    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)

    def find_paths(self, start_node):
        self.distances = {}
        self.previous = {}

        self.distances[start_node] = 0
        self.previous[start_node] = None
        queue = [start_node]

        for node in queue:
            distance = self.distances[node]
            for next_node in self.edges[node]:
                if next_node not in self.distances:
                    self.distances[next_node] = distance + 1
                    self.previous[next_node] = node
                    queue.append(next_node)
```

Sanakirja `self.distances` sisältää etäisyydet lähtösolmusta kaikkiin solmuihin, joihin pääsee kulkemaan kaaria pitkin. Kun solmu tulee vastaan leveyshaussa, sen etäisyydeksi asetetaan yhtä suurempi kuin edellisen solmun etäisyys.

Sanakirja `self.previous` sisältää kunkin solmun edellisen solmun lyhimmällä polulla. Tämän sanakirjan avulla voidaan leveyshaun jälkeen etsiä käänteisessä järjestyksessä solmut, jotka ovat lyhimmän polun varrella.

Esimerkiksi seuraava koodi etsii lyhimmät polut solmusta 1 alkaen, tulostaa etäisyydet solmuihin sekä etsii solmuun 5 johtavan polun.

```python
s = ShortestPaths(5)

s.add_edge(1, 2)
s.add_edge(1, 3)
s.add_edge(1, 4)
s.add_edge(2, 4)
s.add_edge(2, 5)
s.add_edge(3, 4)
s.add_edge(4, 5)

s.find_paths(1)

print(s.distances) # {1: 0, 2: 1, 3: 1, 4: 1, 5: 2}

node = 5
path = []
while node:
    path.append(node)
    node = s.previous[node]
    
path.reverse()
print(path) # [1, 2, 5]
```

Huomaa, että polun etsinnässä polku muodostuu takaperin, koska sanakirja `self.previous` kertoo edellisen solmun polulla. Tämän takia polku käännetään ympäri metodilla `reverse` ennen tulostamista.

## Labyrintti verkkona
