---
title: 14. Lyhimmät polut
slug: osa14
sections:
  - Bellman-Ford-algoritmi
  - Dijkstran algoritmi
  - Floyd-Warshall-algoritmi
---

# 14. Lyhimmät polut

Tässä luvussa tarkastelemme tilannetta, jossa verkko on _painotettu_ (_weighted_) eli jokaisella kaarella on paino. Tällaisessa verkossa polun pituus on summa polulla olevien kaarten painoista.

Seuraavassa kuvassa on esimerkki painotetusta verkosta:

![](../lyhpol.png)

Tässä verkossa esimerkiksi polun $$1 \rightarrow 3 \rightarrow 2$$ pituus on $$1+4=5$$, koska kaaren $$1 \rightarrow 3$$ paino on $$1$$ ja kaaren $$3 \rightarrow 2$$ paino on $$4$$.

Olemme käyttäneet aiemmin leveyshakua verkon lyhimpien polkujen etsimiseen, mutta algoritmi ei sovellu käytettäväksi painotetuissa verkoissa. Tässä luvussa tutustumme kolmeen algoritmiin, joilla voidaan etsiä lyhimpiä polkuja painotetuissa verkoissa.

## Bellman-Ford-algoritmi

Bellman-Ford-algoritmi etsii lyhimmät polut alkusolmusta kaikkiin verkon solmuihin. Algoritmi pitää yllä tietoa etäisyyksistä verkon solmuihin. Alussa etäisyys alkusolmuun on $$0$$ ja etäisyys kaikkiin muihin solmuihin on $$\infty$$.

Algoritmi muodostuu $$n-1$$ kierroksesta. Jokaisella kierroksella algoritmi käy läpi kaikki verkon kaaret ja koettaa pienentää etäisyyksiä kaarten avulla. Kun kaari on solmusta $$a$$ solmuun $$b$$, algoritmi tarkastaa, saadaanko kaaren avulla pienempi etäisyys solmun $$a$$ kautta solmuun $$b$$. Jos etäisyys on pienempi, algoritmi merkitsee muistiin uuden etäisyyden.

Bellman-Ford-algoritmi voidaan toteuttaa seuraavasti:

```python
class BellmanFord:
    def __init__(self, n):
        self.n = n
        self.edges = []
        
    def add_edge(self, a, b, w):
        self.edges.append((a, b, w))
        
    def find_paths(self, start_node):
        self.distances = {}
        for node in range(1, self.n + 1):
            self.distances[node] = float("inf")
        self.distances[start_node] = 0
        
        for _ in range(self.n - 1):
            for edge in self.edges:
                a, b, w = edge
                new_distance = self.distances[a] + w
                if new_distance < self.distances[b]:
                    self.distances[b] = new_distance
```

Algoritmin käytössä on lista `edges`, joka sisältää kunkin kaaren alku- ja loppusolmun sekä painon. Tämän avulla algoritmin kierroksissa on kätevää käydä läpi kaikki verkon kaaret. Algoritmi muodostaa sanakirjan `distances`, jossa on etäisyys alkusolmusta kuhunkin solmuun.

Algoritmia voidaan käyttää näin:

```python
b = BellmanFord(5)

b.add_edge(1, 2, 8)
b.add_edge(1, 3, 1)
b.add_edge(2, 5, 5)
b.add_edge(3, 2, 4)
b.add_edge(3, 4, 2)
b.add_edge(4, 2, 1)
b.add_edge(4, 5, 3)

b.find_paths(1)
print(b.distances) # {1: 0, 2: 4, 3: 1, 4: 3, 5: 6}
```

Seuraava taulukko näyttää etäisyydet solmusta $$1$$ muihin solmuihin ja etäisyyksiä vastaavat polut:

Kohdesolmu | Etäisyys | Polku
== | == | ==
$$1$$ | $$0$$ | $$1$$
$$2$$ | $$4$$ | $$1 \rightarrow 3 \rightarrow 4 \rightarrow 2$$
$$3$$ | $$1$$ | $$1 \rightarrow 3$$
$$4$$ | $$3$$ | $$1 \rightarrow 3 \rightarrow 4$$
$$5$$ | $$6$$ | $$1 \rightarrow 3 \rightarrow 4 \rightarrow 5$$

### Algoritmin tutkiminen

Algoritmin toiminnasta saa paremman kuvan lisäämällä siihen tulostuksen aina, kun algoritmi muuttaa etäisyyttä:

```python
                if new_distance < self.distances[b]:
                    print("update", a, b, new_distance)
                    self.distances[b] = new_distance
```

Tämän jälkeen algoritmin tulostus äskeisessä verkossa on seuraava:

```python
update 1 2 8
update 1 3 1
update 2 5 13
update 3 2 5
update 3 4 3
update 4 2 4
update 4 5 6
```

Tässä jokainen rivi näyttää yhden algoritmin tekemän muutoksen etäisyyksiin. Ensimmäinen muutos on, että solmun $$2$$ etäisyydeksi tulee $$8$$. Tässä käytetään kaarta $$1 \rightarrow 2$$, jonka paino on $$8$$. Koska etäisyys solmuun $$1$$ on $$0$$, tämän kaaren avulla saadaan uusi etäisyys $$8$$, joka korvaa vanhan etäisyyden $$\infty$$.

Tästä huomaa, että etäisyys solmuun saattaa muuttua useita kertoja algoritmin aikana. Esimerkiksi etäisyys solmuun $$2$$ on ensin $$\infty$$, sitten $$8$$ kaaren $$1 \rightarrow 2$$ kautta, sitten $$5$$ kaaren $$3 \rightarrow 2$$ kautta ja lopulta $$4$$ kaaren $$4 \rightarrow 2$$ kautta.

### Algoritmin analyysi

Kun Bellman-Ford-algoritmin ensimmäisen kierroksen jälkeen se on löytänyt kaikki lyhimmät polut, joissa on yksi kaari. Algoritmin toisen kierroksen jälkeen se on löytänyt kaikki lyhimmät polut, joissa on kaksi kaarta. Yleisemmin $$k$$ kierroksen jälkeen algoritmi on löytänyt kaikki lyhimmät polut, joissa on $$k$$ kaarta.

Kun verkossa on $$n$$ solmua, jokaisessa lyhimmässä polussa on enintään $$n-1$$ kaarta. Tämä johtuu siitä, että jos polussa olisi $$n$$ tai enemmän kaaria, se kävisi monta kertaa samassa solmussa. Tällainen polku ei kuitenkaan voisi olla lyhin polku. Niinpä $$n-1$$ kierroksen jälkeen algoritmi on löytänyt kaikki lyhimmät polut.

Koska algoritmi suorittaa $$n-1$$ kierrosta ja käy läpi jokaisella kierroksella $$m$$ kaarta, algoritmin aikavaativuus on $$O(nm)$$.

### Negatiiviset syklit

Bellman-Ford-algoritmi ei anna mielekästä tulosta, jos verkossa on negatiivinen sykli. Negatiivinen sykli tarkoittaa sykliä, jossa kaarten yhteispaino on negatiivinen. Tällaista sykliä kulkemalla polkuja voi lyhentää loputtomasti, jolloin lyhimmän polun käsite ei ole hyvin määritelty.

Seuraavassa on esimerkki tilanteesta, jossa verkossa on negatiivinen sykli:

```python
b = BellmanFord(4)

b.add_edge(1, 2, 1)
b.add_edge(2, 3, 1)
b.add_edge(3, 2, -2)
b.add_edge(2, 4, 1)

b.find_paths(1)
print(b) # {1: 0, 2: -2, 3: 0, 4: -1}
```

Verkossa on kaari $$2 \rightarrow 3$$ painolla $$1$$ sekä kaari $$3 \rightarrow 2$$ painolla $$-2$$. Kun kuljetaan näitä kaaria edestakaisin, polun pituus vähenee aina $$1$$:llä. Tämän takia polun pituus solmusta $$1$$ mihin tahansa muuhun solmuun saadaan miten pieneksi tahansa. Tässä tapauksessa algoritmin antama tulos ei ole mielekäs.

Algoritmin avulla voidaan kuitenkin havaita verkossa oleva negatiivinen sykli. Tämä voidaan tehdä suorittamalla algoritmia $$n$$ kierrosta tavallisen $$n-1$$ sijasta. Verkossa on negatiivinen sykli, jos jokin etäisyys paranee vielä viimeisellä kierroksella.

## Dijkstran algoritmi

Dijkstran algoritmi etsii Bellman-Ford-algoritmin tavoin lyhimmät polut alkusolmusta kaikkiin muihin solmuihin. Algoritmi on vaikeampi toteuttaa, mutta se on suurilla verkoilla selvästi tehokkaampi. Algoritmi olettaa, että verkossa ei ole kaaria, joilla on negatiivinen paino.

Dijkstran algoritmin lähtökohta on sama kuin Bellman-Ford-algoritmilla: jokaisella solmulla on etäisyys niin, että lähtösolmun etäisyys on $$0$$ ja kaikkien muiden solmujen etäisyys on $$\infty$$. Tämän jälkeen algoritmi parantaa etäisyyksiä, kunnes jokaisen solmun pienin etäisyys on löytynyt.

Algoritmi ottaa joka vaiheessa käsittelyyn solmun, jossa se ei ole vielä käynyt ja jonka etäisyys on mahdollisimman pieni. Algoritmi käy läpi solmusta lähtevät kaaret ja pienentää niiden avulla etäisyyksiä muihin solmuihin. Tämän jälkeen algoritmi merkitsee solmun käydyksi eikä palaa siihen enää uudestaan.

Dijkstran algoritmi voidaan toteuttaa seuraavasti:

```python
import heapq

class Dijkstra:
    def __init__(self, n):
        self.n = n
        self.graph = {node: [] for node in range(1, n + 1)}
        
    def add_edge(self, a, b, w):
        self.graph[a].append((b, w))
        
    def find_paths(self, start_node):
        self.distances = {}
        for node in range(1, self.n + 1):
            self.distances[node] = float("inf")
        self.distances[start_node] = 0
        
        queue = []
        heapq.heappush(queue, (0, 1))
        
        visited = set()
        while queue:
            node = heapq.heappop(queue)[1]
            if node in visited:
                continue
            visited.add(node)

            for target, weight in self.graph[node]:
                new_distance = self.distances[node] + weight
                if new_distance < self.distances[target]:
                    self.distances[target] = new_distance
                    entry = (new_distance, target)
                    heapq.heappush(queue, entry)

```

Tässä verkko on tallennettu vieruslistoina. Jokainen vieruslista sisältää pareja muotoa $$(b,w)$$: kaari johtaa solmuun $$b$$ ja sen paino on $$w$$.

Toteutuksessa on käytössä keko `queue`, jonka jokainen alkio on pari muotoa $$(d,a)$$: etäisyys solmuun $$a$$ on $$d$$. Algoritmi ottaa keosta käsittelyyn solmun, jonka etäisyys on pienin. Jos algoritmi ei ole vielä käynyt solmussa, se päivittää etäisyyksiä ja lisää päivitetyt etäisyydet kekoon.

Algoritmia voidaan käyttää näin:

```python
d = Dijkstra(5)

d.add_edge(1, 2, 8)
d.add_edge(1, 3, 1)
d.add_edge(2, 5, 5)
d.add_edge(3, 2, 4)
d.add_edge(3, 4, 2)
d.add_edge(4, 2, 1)
d.add_edge(4, 5, 3)

d.find_paths(1)
print(d.distances) # {1: 0, 2: 4, 3: 1, 4: 3, 5: 6}
```

### Algoritmin analyysi

Dijkstran algoritmi ottaa joka vaiheessa käsittelyyn solmun, jonka etäisyys on mahdollisimman pieni. Tämän jälkeen solmun etäisyys ei enää muutu, koska algoritmi käsittelee jokaisen solmun vain kerran.

Algoritmin toiminta perustuu oletukseen, ettei verkossa ole negatiivisia kaaria. Tällöin pienimmän etäisyyden solmu on turvallinen valinta, koska solmuun ei voi olla lyhempää polkua jonkin toisen vielä käsittelemättömän solmun kautta. Jos tällainen polku olisi, toisen solmun etäisyys tulisi olla pienempi kuin käsiteltävän solmun etäisyys, mikä ei ole mahdollista.

Algoritmin aikavaativuus on $$O(n + m \log m)$$. Aikavaativuus $$O(n)$$ tulee siitä, että algoritmi käy läpi verkon solmut. Aikavaativuus $$O(m \log m)$$ puolestaan tulee siitä, että algoritmi laittaa kutakin kaarta kohden enintään yhden etäisyyden kekoon ja poistaa sen myöhemmin keosta.

## Floyd-Warshall-algoritmi

Floyd-Warshall-algoritmi etsii lyhimmät polut verkon kaikkien solmuparien välillä. Toisin kuin muissa tämän luvun algoritmeissa Floyd-Warshall-algoritmille ei anneta alkusolmua, vaan se etsii yhdellä kertaa polut kaikista solmuista alkaen.

Bellman-Ford-algoritmin tavoin Floyd-Warshall-algoritmia voidaan käyttää millä tahansa verkolla, kunhan verkossa ei ole negatiivista sykliä.

Algoritmi käsittelee verkkoa _vierusmatriisina_ (_adjacency matrix_), jossa rivin $$a$$ sarakkeessa $$b$$ ilmoitetaan kaaren pituus solmusta $$a$$ solmuun $$b$$. Jos $$a=b$$, pituus on $$0$$, ja jos verkossa ei ole kaarta solmusta $$a$$ solmuun $$b$$, pituus on $$\infty$$.

Tarkastellaan esimerkkinä seuraavaa verkkoa:

![](../lyhpol.png)

Tämän verkon sisältö voidaan esittää vierusmatriisina seuraavasti:

<span></span> | $$1$$ | $$2$$ | $$3$$ | $$4$$ | $$5$$
$$1$$ | $$0$$ | $$8$$ | $$1$$ | $$\infty$$ | $$\infty$$
$$2$$ | $$\infty$$ | $$0$$ | $$\infty$$ | $$\infty$$ | $$5$$
$$3$$ | $$\infty$$ | $$4$$ | $$0$$ | $$2$$ | $$\infty$$
$$4$$ | $$\infty$$ | $$1$$ | $$\infty$$ | $$0$$ | $$3$$
$$5$$ | $$\infty$$ | $$\infty$$ | $$\infty$$ | $$\infty$$ | $$0$$

Esimerkiksi rivin $$3$$ sarakkeessa $$2$$ on luku $$4$$, koska verkossa on solmusta $$3$$ solmuun $$2$$ kaari, jonka pituus on $$4$$.

Floyd-Warhall-algoritmi muodostaa etäisyysmatriisin, jossa rivin $$a$$ sarake $$b$$ ilmaisee lyhimmän polun pituuden solmusta $$a$$ solmuun $$b$$. Etäisyysmatriisin pohjana on verkon vierusmatriisi, joka sisältää niiden polkujen pituudet, joissa on enintään yksi kaari.

Algoritmi muodostuu kolmesta sisäkkäisestä silmukasta, joista jokainen käy läpi verkon solmut. Ensimmäinen silmukka valitsee välisolmun $$k$$ ja sisemmät silmukat etsivät polkuja, joissa polun osana on solmu $$k$$. Jos polun pituus lyhenee kulkemalla solmun $$k$$ kautta, uusi pituus merkitään muistiin.

Algoritmi voidaan toteuttaa seuraavasti:

```python
class FloydWarshall:
    def __init__(self, n):
        self.nodes = range(1, n + 1)
        self.graph = {}
        for a in self.nodes:
            for b in self.nodes:
                self.graph[(a, b)] = 0 if a == b else float("inf")

    def add_edge(self, a, b, w):
        self.graph[(a, b)] = min(self.graph[(a, b)], w)

    def find_distances(self):
        distances = self.graph.copy()

        for k in self.nodes:
            for a in self.nodes:
                for b in self.nodes:
                    distances[(a, b)] = min(distances[(a, b)],
                                            distances[(a, k)] + distances[(k, b)])

        return distances
```

Sanakirja `graph` sisältää vierusmatriisin. Alussa etäisyys solmusta $$a$$ solmuun $$b$$ on $$0$$, jos $$a=b$$ ja muuten $$\infty$$. Kun verkkoon lisätään kaari, sanakirjaan päivitetään sen pituus. Huomaa, että jos lisätään monta kaarta solmusta $$a$$ solmuun $$b$$, sanakirjaan jää talteen lyhimmän kaaren pituus.

Metodi `find_distances` muodostaa etäisyysmatriisin vierusmatriisin perusteella ja palauttaa sen. Metodi muodostuu kolmesta sisäkkäisestä silmukasta, jotka käyvät läpi verkon solmut.

Seuraava koodi testaa algoritmia:

```python
f = FloydWarshall(5)

f.add_edge(1, 2, 8)
f.add_edge(1, 3, 1)
f.add_edge(2, 5, 5)
f.add_edge(3, 2, 4)
f.add_edge(3, 4, 2)
f.add_edge(4, 2, 1)
f.add_edge(4, 5, 3)

distances = f.find_distances()

print(distances[(1, 4)]) # 3
print(distances[(2, 1)]) # inf
print(distances[(3, 5)]) # 5
```

Tämä tarkoittaa, että etäisyys solmusta $$1$$ solmuun $$4$$ on $$3$$, verkossa ei ole polkua solmusta $$2$$ solmuun $$1$$ ja etäisyys solmusta $$3$$ solmuun $$5$$ on $$5$$.

Tässä tapauksessa metodin `find_distances` palauttama etäisyysmatriisi on seuraava:

<span></span> | $$1$$ | $$2$$ | $$3$$ | $$4$$ | $$5$$
$$1$$ | $$0$$ | $$4$$ | $$1$$ | $$3$$ | $$6$$
$$2$$ | $$\infty$$ | $$0$$ | $$\infty$$ | $$\infty$$ | $$\infty$$
$$3$$ | $$\infty$$ | $$3$$ | $$0$$ | $$2$$ | $$5$$
$$4$$ | $$\infty$$ | $$1$$ | $$\infty$$ | $$0$$ | $$3$$
$$5$$ | $$\infty$$ | $$\infty$$ | $$\infty$$ | $$\infty$$ | $$0$$

### Algoritmin analyysi

Kun välisolmuna on $$k$$, algoritmi muodostaa lyhimmät polut, joissa polun osana on solmu $$k$$ ja kaikki muut välisolmut ovat solmuja $$1 \dots k-1$$. Koska $$k$$ on vuorollaan $$1,2,\dots,n$$, algoritmi muodostaa lopulta kaikki verkon lyhimmät polut.

Algoritmin aikavaativuus on $$O(n^3)$$, koska se muodostuu kolmesta sisäkkäisestä silmukasta, jotka käyvät läpi verkon solmut.
