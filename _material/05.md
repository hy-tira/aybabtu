---
title: 5. Järjestäminen
slug: osa5
permalink: /:title/
---

# 5. Järjestäminen

TODO

## Järjestäminen Pythonissa

Pythonissa listassa on metodi `sort`, joka järjestää sen sisällön:

```python
numbers = [4, 2, 1, 2, 5, 4, 5, 2]
numbers.sort()
print(numbers) # [1, 2, 2, 2, 4, 4, 5, 5]
```

Toinen tapa järjestää lista on käyttää funktiota `sorted`, joka palauttaa sille annetun listan järjestettynä:

```python
numbers = [4, 2, 1, 2, 5, 4, 5, 2]
print(sorted(numbers)) # [1, 2, 2, 2, 4, 4, 5, 5]
```

Voimme myös korvata listan järjestetyllä listalla näin:

```python
numbers = [4, 2, 1, 2, 5, 4, 5, 2]
numbers = sorted(numbers)
print(numbers) # [1, 2, 2, 2, 4, 4, 5, 5]
```

Metodin `sort` ja funktion `sorted` erona on, että `sort` muuttaa olemassa olevan listan sisällön, kun taas `sorted` luo uuden järjestetyn listan. Usein parempi valinta on `sorted`, kuten huomaamme seuraavassa tehtävässä.

## Esimerkki: Pienin ero

<div class="note" markdown="1">

Annettuna on lista lukuja. Mikä on pienin ero kahden luvun välillä?

Esimerkiksi kun lista on $$[25,1,11,19,33,13,4,40]$$, haluttu vastaus on $$2$$, koska pienin ero on lukujen $$11$$ ja $$13$$ välillä.

</div>

Voimme ratkaista tämän tehtävän tehokkaasti järjestämisen avulla, koska järjestämisen jälkeen listassa ovat vierekkäin luvut, joiden välillä on pienin ero. Tämän ansiosta pienin ero voidaan löytää helposti käymällä läpi lista vasemmalta oikealle ja vertaamalla joka kohdassa vierekkäisiä lukuja.

Yllä olevassa esimerkissä lista järjestettynä on $$[1,4,11,13,19,25,33,40]$$ ja luvut $$11$$ ja $$13$$ ovat vierekkäin.

Seuraava funktio `min_diff` toteuttaa algoritmin:

```python
def min_diff(numbers):
    numbers = sorted(numbers)
    n = len(numbers)
    result = numbers[1] - numbers[0]
    for i in range(2, n):
        result = min(result, numbers[i] - numbers[i - 1])
    return result
```

Algoritmi järjestää ensin listan ajassa $$O(n \log n)$$ ja käy sitten läpi kaikki vierekkäiset luvut silmukalla ajassa $$O(n)$$, joten algoritmin aikavaativuus on $$O(n \log n)$$.

Huomaa, että voisimme käyttää funktion alussa myös listan metodia `sort`:

```python
def min_diff(numbers):
    numbers.sort()
    ...
```

Tässä on kuitenkin ongelmana, että parametrina annetun listan järjestäminen heijastuu myös funktion `min_diff` kutsukohtaan. Tämä ei ole toivottava ilmiö, koska funktion ei pitäisi muuttaa listan sisältöä. Seuraavat koodit havainnollistavat asiaa:


{: .code-title }
Käytössä `sort`
```python
numbers = [25, 1, 11, 19, 33, 13, 4, 40]
print(min_diff(numbers)) # 2
print(numbers) # [1, 4, 11, 13, 19, 25, 33, 40]
```

{: .code-title }
Käytössä `sorted`
```python
numbers = [25, 1, 11, 19, 33, 13, 4, 40]
print(min_diff(numbers)) # 2
print(numbers) # [25, 1, 11, 19, 33, 13, 4, 40]
```

Kun käytössä on metodi `sort`, funktion `min_diff` kutsuminen järjestää sivuvaikutuksena listan `numbers`. Kun käytössä on funktio `sorted`, lista `numbers` ei muutu, koska funktio `sorted` luo uuden järjestetyn listan.

## Hajautus vs. järjestäminen

Monessa tehtävässä on kaksi mahdollisuutta tehokkaan ratkaisun luomiseen: hajautus tai järjestäminen. Tarkastellaan esimerkkinä tehtävää, jonka ratkaisimme aiemmin hajautuksen avulla:

<div class="note" markdown="1">

Annettuna on lista lukuja. Montako eri lukua listalla on?

Esimerkiksi kun lista on $$[3,1,2,1,5,2,2,3]$$, haluttu vastaus on $$4$$, koska eri luvut ovat $$1$$, $$2$$, $$3$$ ja $$5$$.

</div>

Ratkaisimme tehtävän aiemmin hajautuksen avulla näin:

{: .code-title }
Algoritmi 1
```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        seen.add(x)
    return len(seen)
```

Voimme ratkaista tehtävän myös toisella tavalla järjestämisen avulla. Ideana on, että järjestetyssä listassa yhtä suuret luvut ovat peräkkäin. Niinpä voimme laskea eri luvut käymällä järjestetyn listan läpi ja kasvattamalla laskuria aina luvun vaihtuessa.

Tässä on järjestämistä käyttävä algoritmi:

{: .code-title }
Algoritmi 2
```python
def count_distinct(numbers):
    numbers = sorted(numbers)    
    result = 1
    for i in range(1, n):
        if numbers[i] != numbers[i - 1]:
            result += 1
    return result
```

Hajautusta käyttävä algoritmi vie aikaa $$O(n)$$ ja järjestämistä käyttävä algoritmi vie aikaa $$O(n \log n)$$, mutta miten nopeita algoritmit ovat käytännössä?

Tehdään seuraavaksi testi, joka vertailee algoritmien tehokkuutta. Koska molemmat algoritmit ovat tehokkaita, toteutetaan testi niin, että listan koko on aina suuri ($$n=10^7$$). Koska listalla olevien lukujen suuruus saattaa vaikuttaa tehokkuuteen, luodaan lista niin, että jokainen luku on satunnainen luku väliltä $$1 \dots k$$. Tämän avulla voimme tutkia, miten $$k$$:n muuttuminen vaikuttaa tehokkuuteen.

Testikoneella tulokset ovat seuraavat:

| Luvun yläraja $$k$$ | Algoritmi 1 (hajautus) | Algoritmi 2 (järjestäminen)
| --- | --- | --- | 
| $$10^3$$ | 0.46 s | 3.18 s |
| $$10^4$$ | 0.56 s | 4.50 s |
| $$10^5$$ | 1.16 s | 5.74 s |
| $$10^6$$ | 2.56 s | 6.38 s |
| $$10^7$$ | 2.56 s | 6.48 s |

Tässä tapauksessa vaikuttaa siltä, että hajautusta käyttävä algoritmi on tehokkaampi. Se on myös koodiltaan yksinkertaisempi, koska silmukassa riittää lisätä listan luvut `set`-rakenteeseen eikä vertailla vierekkäisiä lukuja keskenään.

## Esimerkki: Ravintola

<div class="note" markdown="1">

Ravintolassa käy päivän aikana $$n$$ asiakasta ja tiedät, milloin kukin asiakas saapuu ja lähtee. Jos asiakas lähtee samalla hetkellä kuin toinen asiakas saapuu, tulkintana on, että he ovat yhtä aikaa ravintolassa. Tehtäväsi on selvittää suurin määrä asiakkaita, jotka ovat yhtä aikaa ravintolassa.

Tarkastellaan esimerkkinä seuraavaa tilannetta:

Asiakas | Saapumisaika | Lähtöaika
--- | ---
#1 | 6 | 8
#2 | 3 | 7
#3 | 6 | 9
#4 | 1 | 5
#5 | 2 | 8

Tässä tapauksessa suurin määrä asiakkaita on 4 asiakasta: asiakkaat #1, #2, #3 ja #5 ovat yhtä aikaa ravintolassa aikavälillä 6–7.

</div>

```python
def max_customers(arrivals, departures):
    events = []
    for time in arrivals:
        events.append((time, 1))
    for time in departures:
        events.append((time, 2))
        
    events = sorted(events)
    
    counter = 0
    result = 0
    for event in events:
        if event[1] == 1:
            counter += 1
        if event[1] == 2:
            counter -= 1
        result = max(result, counter)
        
    return result
```
