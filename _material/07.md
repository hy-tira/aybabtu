---
title: 7. Puut ja rekursio
slug: osa7
permalink: /:title/
---

# 7. Puut ja rekursio

## Puurakenne

_Puu_ (_tree_) on tietorakenne, joka muodostuu solmuista ja niiden välisistä yhteyksistä. Seuraavassa on esimerkkinä puu, jossa on kuusi solmua:


KUVA

Puun ylin solmu on nimeltään _juuri_ (_root_). Solmun _lapsi_ (_child_) on sen alapuolella oleva solmu, johon on yhteys solmusta. Solmun _vanhempi_ (_parent_) on solmu, jonka lapsi solmu on. Jos solmulla ei ole lapsia, se on _lehti_ (_leaf_).

Esimerkissä puun juuri on solmu 1. Solmun 1 lapset ovat solmut 2, 3 ja 4. Solmun 2 vanhempi on solmu 1. Puun lehtiä ovat solmut 3, 4, 5 ja 6.

Solmun _alipuu_ (_subtree_) sisältää solmut, joihin pääsee kulkemalla solmusta alaspäin yhteyksiä pitkin. Esimerkissä solmun 1 alipuu sisältää puun kaikki solmut ja solmun 2 alipuu sisältää solmut 2, 5 ja 6.

Solmun _syvyys_ (_depth_) tarkoittaa, miten matalalla solmu on puussa. Juuren syvyys on 0 ja muilla solmuilla syvyys on yhtä suuri kuin niiden vanhemman syvyys. Esimerkissä solmun 2 syvyys on 1 ja solmun 5 syvyys on 2.

Puun _korkeus_ (_height_) on suurin puussa esiintyvä solmun syvyys. Esimerkissä puun korkeus on 2, koska solmujen 5 ja 6 syvyys on 2.

## Puun käsittely

Voimme esittää puun solmun Pythonissa seuraavan luokan `Node` avulla:

```python
class Node:
    def __init__(self, value, children=[]):
        self.value = value
        self.children = children
        
    def __repr__(self):
        return str(self.value)        
```

Tässä kentässä `value` on solmuun liittyvä arvo ja lista `children` sisältää viittaukset solmun lapsiin. Oletuksena `children` on tyhjä eli solmulla ei ole lapsia.

Nyt voimme määritellä seuraavasti äskeisen esimerkkipuun:
        
```python
root = Node(1, [Node(2, [Node(5), Node(6)]), Node(3), Node(4)])
```

Luonteva tapa käsitellä puuta on käyttää rekursiota. Esimerkiksi seuraava funktio `traverse` käy läpi kaikki solmut, jotka ovat solmun `node` alipuussa:

```python
def traverse(node):
    print(node.value)
    for child in node.children:
        traverse(child)
```

Kun funktiolle annetaan parametrina puun juuri, se käy läpi kaikki puun solmut:

```python
traverse(root)
```

Esimerkkipuussa funktion tulostus on seuraava:

```
1
2
5
6
3
4
```

Funktio `traverse` tulostaa ensin sille annetun solmun arvon (`node.value`). Tämän jälkeen funktio käy läpi kaikki solmun lapset (`node.children`) ja kutsuu jokaisen lapsen kohdalla itseään rekursiivisesti.

Voimme vielä selventää funktion toimintaa muuttamalla sitä seuraavasti:

```python
def traverse(node):
    print("enter", node.value)
    for child in node.children:
        traverse(child)
    print("leave", node.value)
```

Nyt funktio tulostaa "enter $$x$$", kun solmun $$x$$ käsittely alkaa, ja "leave $$x$$", kun solmun $$x$$ käsittely päättyy. Esimerkkipuussa funktio tulostaa:

```
enter 1
enter 2
enter 5
leave 5
enter 6
leave 6
leave 2
enter 3
leave 3
enter 4
leave 4
leave 1
```

## Lista oletusparametrina

Tarkastellaan vielä luokan `Node` metodia `__init__`:

```python
    def __init__(self, value, children=[]):
        self.value = value
        self.children = children
```

Yllättävä piirre Pythonissa on, että parametrin `children` oletusarvo tyhjä lista luodaan vain kerran ja on _yhteinen_ kaikille luokasta luoduille olioille. Tämän vuoksi seuraava koodi ei toimi halutulla tavalla:

```python
root = Node(1)
root.children.append(Node(2))

print(root.children) # [2]
print(root.children[0].children) # [2]
```

Tässä molemmilla solmuilla on yhteinen tyhjä lista. Kun solmun 1 listalle lisätään viittaus solmuun 2, tämä viittaus ilmestyy myös solmun 2 listalle.


Voimme korjata asian muuttamalla metodia `__init__` näin:

```python
    def __init__(self, value, children=None):
        self.value = value
        self.children = children if children else []
```

Nyt parametrin `children` oletusarvona on `None`. Lauseke `children if children else []` asettaa kentän `self.children` arvoksi `children`, jos lista on annettu, ja muuten tyhjän listan. Tämän jälkeen koodi toimii näin:

```python
root = Node(1)
root.children.append(Node(2))

print(root.children) # [2]
print(root.children[0].children) # []
```

## Tiedon laskeminen puusta



```python
root = Node(1, [Node(2, [Node(5), Node(6)]), Node(3), Node(4)])
```

### Solmujen määrä

Seuraava funktio laskee solmujen määrän solmun `node` alipuussa:

```python
def count_nodes(node):
    result = 1
    for child in node.children:
        result += count_nodes(child)
    return result
```

### Lehtien määrä

Seuraava funktio laskee lehtien määrän solmun `node` alipuussa:

```python
def count_leaves(node):
    result = 1 if node.children == [] else 0
    for child in node.children:
        result += count_leaves(child)
    return result
```

### Puun korkeus

Seuraava funktio laskee solmun `node` alipuun korkeuden:

```python
def count_height(node):
    result = 0
    for child in node.children:
        result = max(result, count_height(child) + 1)
    return result
```

### Solmun etsiminen

Seuraava funktio tarkastaa, onko solmun `node` alipuussa solmua, jonka arvona on `value`:

```python
def has_value(node, value):
    result = node.value == value
    for child in node.children:
        result = result or has_value(child, value)
    return result
```

### Solmut listaan

Seuraava funktio muodostaa listan solmun `node` alipuun solmuista:

```python
def fetch_nodes(node):
    result = [node]
    for child in node.children:
        result += fetch_nodes(child)
    return result
```

## Esimerkki: Työntekijät

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on puu, joka kuvaa yrityksen henkilöstörakennetta. Tehtäväsi on laskea, monellako työntekijällä on vähintään $$x$$ alaista.

</div>

```python
class Employee:
    def __init__(self, name, subordinates=[]):
        self.name = name
        self.subordinates = subordinates
```

```python
def count_employees(employee, x):
    count_all = 1
    count_x = 0
    for subordinate in employee.subordinates:
        result = count_employees(subordinate, x)
        count_all += result[0]
        count_x += result[1]
    if count_all > x:
        count_x += 1
    return (count_all, count_x)
```

## Esimerkki: Hakemistot ja tiedostot

```
$ tree
.
├── apina
│   ├── a1.py
│   ├── a2.py
│   ├── a3.py
│   └── uusi
│       ├── u1.py
│       └── u2.py
├── banaani
│   ├── b1.py
│   └── b2.py
└── cembalo
    ├── c1.py
    ├── c2.py
    ├── c3.py
    └── c4.py

4 directories, 11 files
```


## Esimerkki: Kuningattaret

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Monellako tavalla shakkilaudalle voidaan sijoittaa kahdeksan kuningatarta niin, että mitkään kaksi kuningatarta eivät uhkaa toisiaan?

</div>

```python
def attack(queen1, queen2):
    if queen1[0] == queen2[0] or queen1[1] == queen2[1]:
        return True
    if abs(queen1[0] - queen2[0]) == abs(queen1[1] - queen2[1]):
        return True
    return False

def count_queens(n, row, queens):
    if row == n:
        return 1
    result = 0
    for col in range(n):
        attacks = [attack(queen, (row, col)) for queen in queens]
        if not any(attacks):
            result += count_queens(n, row + 1, queens + [(row, col)])
    return result

print(count_queens(8, 0, []))
```

