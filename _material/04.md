---
title: 4. Hajautus
slug: osa4
permalink: /:title/
---

# 4. Hajautus

_Hajautus_ (_hashing_) on tekniikka, jota käytetään usein tietorakenteiden toteuttamisessa. Pythonissa hajautusta käyttäviä tietorakenteita ovat `set` (joukko) ja `dict` (sanakirja). Tutustumme tässä luvussa näiden tietorakenteiden käyttämiseen sekä niiden taustalla olevaan teoriaan.

## Joukko

Pythonin tietorakenne `set` pitää yllä alkioiden joukkoa ja tarjoaa tehokkaat operaatiot, joiden avulla voidaan lisätä alkio joukkoon, tarkastaa alkion kuuluminen joukkoon sekä poistaa alkio joukosta.

Seuraava koodi luo joukon `numbers` ja lisää sinne alkioita metodilla `add`:

```python
numbers = set()

numbers.add(1)
numbers.add(2)
numbers.add(3)

print(numbers) # {1, 2, 3}
```

Joukko voidaan myös luoda listan perusteella:

```python
numbers = set([1, 2, 3])
print(numbers) # {1, 2, 3}
```

Operaattori `in` tarkastaa, kuuluuko tietty alkio joukkoon:

```python
numbers = set([1, 2, 3])
print(3 in numbers) # True
print(4 in numbers) # False
```

Metodi `remove` puolestaan poistaa alkion joukosta:

```python
numbers = set([1, 2, 3])
numbers.remove(2)
print(numbers) # {1, 3}
```

## Lista vs. joukko

### Tehokkuus

Listassa alkion lisääminen on tehokasta, mutta on hidasta tarkastaa, onko alkio listassa, sekä poistaa alkio listasta.

Joukossa on tehokasta lisätä alkio joukkoon, tarkastaa alkion kuuluminen joukkoon sekä poistaa alkio joukosta.

Operaatio | Lista | Joukko
--- | --- | ---
Alkion lisääminen (`append`/`add`) | $$O(1)$$ | $$O(1)$$
Alkion tarkastaminen (`in`) | $$O(n)$$ | $$O(1)$$
Alkion poistaminen (`remove`) | $$O(n)$$ | $$O(1)$$


### Indeksointi

Listassa alkioita voidaan käsitellä indeksien perusteella:

```python
numbers = [1, 2, 3]
print(numbers[1]) # 2
```

Joukon alkioihin sen sijaan ei voida viitata indekseillä:

```python
numbers = set([1, 2, 3])
print(numbers[1]) # TypeError: 'set' object is not subscriptable
```

### Toistuvat alkiot

Listassa sama alkio voi esiintyä useita kertoja:

```python
numbers = []
numbers.append(5)
numbers.append(5)
numbers.append(5)
print(numbers) # [5, 5, 5]
```

Joukossa sama alkio voi esiintyä enintään kerran. Jos alkio lisätään monta kertaa joukkoon, tällä ei ole vaikutusta:

```python
numbers = set()
numbers.add(5)
numbers.add(5)
numbers.add(5)
print(numbers) # {5}
```


## Esimerkki: Montako eri lukua?

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on lista lukuja. Montako eri lukua listalla on?

Esimerkiksi kun lista on $$[3,1,2,1,5,2,2,3]$$, haluttu vastaus on $$4$$, koska eri luvut ovat $$1$$, $$2$$, $$3$$ ja $$5$$.

</div>

Voimme ratkaista tämän tehtävän listan avulla seuraavasti:

```python
def count_distinct(numbers):
    seen = []
    for x in numbers:
        if x not in seen:
            seen.append(x)
    return len(seen)
```

Algoritmi käy läpi luvut ja lisää luvun listaan `seen`, jos lukua ei ole vielä listassa. Lopuksi listan `seen` koko on yhtä suuri kuin eri lukujen määrä.

Tämä algoritmi on toimiva mutta ei tehokas, koska jokaisella silmukan kierroksella vie aikaa $$O(n)$$ tarkastaa operaattorilla `in`, onko luku listassa. Tämän vuoksi algoritmin aikavaativuus on $$O(n^2)$$.

Algoritmia on kuitenkin helppoa parantaa käyttämällä listan sijasta joukkoa. Tällöin algoritmi muuttuu näin:

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        if x not in seen:
            seen.add(x)
    return len(seen)
```

Tällä muutoksella on suuri vaikutus algoritmin tehokkuuteen. Muutoksen jälkeen operaattori `in` vie aikaa $$O(1)$$ ja algoritmin aikavaativuus on vain $$O(n)$$.

Koodia on mahdollista tiivistää, koska sama alkio ei mene useita kertoja joukkoon. Niinpä koodista voi poistaa tähän liittyvän tarkastuksen:

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        seen.add(x)
    return len(seen)
```

Itse asiassa koodia voi tiivistää vielä lisää luomalla joukon suoraan listan pohjalta. Tämän ansiosta riittää loppujen lopuksi yksi rivi koodia:

```python
def count_distinct(numbers):
    return len(set(numbers))
```

## Sanakirja

Pythonin tietorakenne `dict` eli sanakirja on tietorakenne, johon voidaan tallentaa avain-arvo-pareja. Esimerkiksi seuraava koodi luo sanakirjan `weights`, jossa avaimet ovat merkkijonoja ja arvot ovat lukuja.

```python
weights = {}

weights["apina"] = 100
weights["banaani"] = 1
weights["cembalo"] = 500
```

Yllä olevan sanakirjan voi luoda myös näin:

```python
weights = {"apina": 100, "banaani": 1, "cembalo": 500}
```
Sanakirjaa voi ajatella listan yleistyksenä: listassa avaimet ovat indeksit $$0 \dots n-1$$ kun taas sanakirjassa avaimet voivat olla mitä tahansa alkioita. Sanakirjan arvoja voi käsitellä samaan tapaan kuin listan arvoja:

```python
print(weights["apina"]) # 100
weights["apina"] = 150
print(weights["apina"]) # 150
```

Operaattori `in` tarkastaa, onko sanakirjassa tiettyä avainta:

```python
print("apina" in weights) # True
print("ananas" in weights) # False
```

Komento `del` poistaa avaimen ja siihen liittyvän arvon sanakirjasta:

```python
print(weights) # {'apina': 100, 'banaani': 1, 'cembalo': 500}
del weights["banaani"]
print(weights) # {'apina': 100, 'cembalo': 500}
```

Sanakirjassa ovat tehokkaita operaatiot, joissa käsitellään tietoa avainten perusteella. Kaikki yllä mainitut operaatiot toimivat ajassa $$O(1)$$.

## Sanakirjan käyttäminen

Seuraavassa on kolme tavallista sanakirjan käyttötarkoitusta algoritmien suunnittelussa. Tutustumme asiaan myöhemmin tässä luvussa tarkemmin esimerkkien kautta.

### Onko alkiota esiintynyt

Sanakirjan avulla voidaan pitää yllä tietoa, mitkä alkiot ovat esiintyneet:

```python
seen = {}
for x in numbers:
    seen[x] = True
```

Tässä tapauksessa avaimeen liittyvä arvo on aina `True`, minkä vuoksi voimme käyttää myös joukkoa kuten aiemmin:

```python
seen = set()
for x in numbers:
    seen.add(x)
```

Voikin ajatella, että joukko on sanakirjan erikoistapaus, jossa jokaisella avaimella on arvona `True` (tai jokin muu sama arvo).

### Alkion esiintymiskerrat

Tavallinen sanakirjan käyttötarkoitus on laskea, montako kertaa mikäkin alkio on esiintynyt tähän mennessä.

```python
count = {}
for x in numbers:
    if x not in count:
        count[x] = 0
    count[x] += 1
```

Koodi laskee esiintymiskerrat sanakirjan `count` avulla. Jos alkiota `x` ei ole vielä sanakirjassa, koodi asettaa sen esiintymiskertojen määräksi `0`. Tämän jälkeen koodi kasvattaa alkion `x` esiintymiskertoja yhdellä.

### Alkion viimeisin esiintymiskohta

Joissakin algoritmeissa on hyödyllistä pitää yllä tietoa siitä, missä kohdassa mikäkin alkio on esiintynyt viimeksi.

```python
last_pos = {}
for i, x in enumerate(numbers):
    last_pos[x] = i
```

Tässä sanakirjassa `last_pos` on kunkin alkion viimeisin esiintymiskohta listassa. Funktion `enumerate` avulla lista voidaan käydä läpi niin, että joka kierroksella `i` sisältää alkion indeksin ja `x` itse alkion.

## Esimerkki: Moodi

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on lista lukuja ja tehtäväsi on selvittää listan _moodi_ eli yleisin luku. Jos moodi ei ole yksikäsitteinen, voit valita minkä tahansa yhtä yleisistä luvuista.

Esimerkiksi kun lista on $$[1,2,3,2,2,3,2,2]$$, haluttu vastaus on $$2$$.

</div>

Voimme ratkaista tehtävän luomalla sanakirjan, jossa avaimet ovat listan lukuja ja arvot ovat niiden esiintymiskertoja. Ideana on käydä läpi lista ja pitää yllä tietoa lukujen esiintymiskerroista ja tämänhetkisestä moodista.

```python
def find_mode(numbers):
    count = {}
    mode_times = 0
    mode_value = 0
    for x in numbers:
        if x not in count:
            count[x] = 0
        count[x] += 1
        if count[x] > mode_times:
            mode_times = count[x]
            mode_value = x
    return mode_value
```

Tässä `count` on sanakirja, joka sisältää lukujen esiintymiskerrat. Lukua `x` käsitellessä `count[x]` kertoo, montako kertaa luku on esiintynyt listassa. Muuttujat `mode_times` ja `mode_value` puolestaan pitävät yllä tietoa moodista: montako kertaa tähän mennessä yleisin luku on esiintynyt ja mikä kyseinen luku on.

Silmukassa tarkastetaan ensin, onko luku `x` esiintynyt aiemmin. Jos ei ole, sen esiintymiskertojen määräksi alustetaan `0`. Tämän jälkeen esiintymiskertojen määrää kasvatetaan yhdellä. Jos luku `x` on esiintynyt useammin kuin tällä hetkellä tiedossa oleva moodi, luvusta `x` tulee uusi moodi ja muuttujat `mode_times` ja `mode_value` päivitetään. Funktio palauttaa muuttujan `mode_value` arvon.

Koodia on mahdollista vielä tiivistää näin:

```python
def find_mode(numbers):
    count = {}
    mode = (0, 0)
    for x in numbers:
        if x not in count:
            count[x] = 0
        count[x] += 1
        mode = max(mode, (count[x], x))
    return mode[1]
```

Nyt koodissa on käytössä pari `mode`, joka korvaa vanhat muuttujat `mode_times` ja `mode_value`. Tämän toteutuksen etuna on, että moodia pystyy päivittämään `max`-funktion avulla. Kun `max`-funktiota käytetään parien kanssa, vertaillaan ensisijaisesti parin ensimmäistä alkiota ja toissijaisesti parin toista alkiota. Koska parin ensimmäinen alkio on esiintymiskertojen määrä, parin arvo on sitä suurempi mitä useammin luku on esiintynyt.

Huomaa, että yllä olevat kaksi funktiota toimivat vähän eri tavalla tilanteessa, jossa on useita mahdollisia vaihtoehtoja moodiksi. Ensimmäinen funktio valitsee moodin, jonka viimeinen esiintymiskerta tulee vastaan ensimmäisenä. Toinen funktio puolestaan valitsee moodin, joka on arvoltaan suurin, koska pareissa vertaillaan toissijaisesti luvun suuruutta.

## Esimerkki: Soittolista

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on soittolista, jossa jokaista laulua vastaa tietty kokonaisluku. Tehtäväsi on selvittää, miten pitkä on pisin soittolistan osa, jossa ei esiinny kahta samaa laulua.

Esimerkiksi kun soittolista on $$[1,2,1,3,5,4,3,1]$$, haluttu vastaus on $$5$$. Tämä vastaa soittolistan osaa $$[2,1,3,5,4]$$.

</div>


```python
def max_length(songs):
    n = len(songs)
    last_pos = {}
    start = 0
    length = 0
    for i, song in enumerate(songs)
        if song in last_pos:
            start = max(start, last_pos[song] + 1)
        length = max(length, i - start + 1)
        last_pos[song] = i
    return length
```

## Miten hajautus toimii?

## Mitä voi hajauttaa?

## Hajautus muissa kielissä

Hajautusta käyttävät tietorakenteet ovat yleisiä eri ohjelmointikielissä. Monissa kielissä Pythonin sanakirjaa vastaa tietorakenne nimeltä _map_, josta voidaan käyttää suomeksi nimeä _hakemisto_.

C++:ssa tietorakenteet `unordered_set` ja `unordered_map` toteuttavat hajautusta käyttävän joukon ja hakemiston.

```cpp
unordered_set<int> numbers;
numbers.add(1);
numbers.add(2);
numbers.add(3);
```

```cpp
unordered_map<string, int> weights;
weights["apina"] = 100;
weights["banaani"] = 1;
weights["cembalo"] = 500;
```

Javassa vastaavat tietorakenteet ovat `HashSet` ja `HashMap`:

```java
HashSet<Integer> numbers = new HashSet<Integer>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
```

```java
HashMap<String, Integer> weights = new HashMap<String, Integer>();
weights.put("apina", 100);
weights.put("banaani", 1);
weights.put("cembalo", 500);
```

JavaScriptissä tietorakenne `Set` toteuttaa joukon:

```js
let numbers = new Set();
numbers.add(1);
numbers.add(2);
numbers.add(3);
```

JavaScriptin perinteinen tapa luoda hakemisto on määritellä olio:

```js
let weights = {};
weights["apina"] = 100;
weights["banaani"] = 1;
weights["cembalo"] = 500;
```

Uudempi tapa on käyttää erillistä tietorakennetta `Map`:

```js
let weights = new Map();
weights.set("apina", 100);
weights.set("banaani", 1);
weights.set("cembalo", 500);
```
