---
title: 12. Binäärihakupuu
slug: osa12
sections:
  - Joukon toteutus
  - Binäärihakupuu Pythonilla
  - Tasapainoisuus
  - "Esimerkki: Asunnot"
  - Miksi ei Pythonissa?
  - Muiden kielten toteutukset
---

# 12. Binäärihakupuu

_Binäärihakupuu_ (_binary search tree_) on tietorakenne, joka on vaihtoehto hajautukselle. Kuten hajautuksessa, sen avulla voidaan pitää yllä joukkoa alkioita niin, että lisääminen, hakeminen ja poistaminen toimivat tehokkaasti.

Binäärihakupuun keskeinen ero hajautukseen verrattuna on, että se säilyttää alkioita suuruusjärjestyksessä. Tämän ansiosta voidaan etsiä esimerkiksi tehokkaasti joukon pienin tai suurin alkio, mikä ei olisi mahdollista hajautuksen avulla.

Pythonin standardikirjastossa ei ole binäärihakupuun toteutusta, minkä vuoksi sen käyttäminen Pythonissa on hankalampaa kuin hajautuksen käyttäminen. Tässä luvussa toteutamme _itse_ binäärihakupuun Pythonilla.

## Joukon toteutus

Binäärihakupuu on binääripuu, jonka jokaisessa solmussa on yksi joukon alkioista. Esimerkiksi seuraava binäärihakupuu vastaa joukkoa $$\{2,3,5,7,8,9\}$$:

![](../bhp.png)

Binäärihakupuun alkiot on järjestetty niin, että jokaisessa solmussa kaikki vasemman alipuun alkiot ovat pienempiä kuin solmun alkio ja vastaavasti kaikki oikean alipuun alkiot ovat suurempia kuin alkio. Esimerkiksi yllä olevassa puussa juuressa on alkio $$5$$, minkä vuoksi kaikki vasemman alipuun alkiot ovat pienempiä kuin $$5$$ ja kaikki oikean alipuun alkiot ovat suurempia kuin $$5$$.

Katsotaan seuraavaksi, miten binäärihakupuun avulla voidaan toteuttaa joukkoon liittyviä operaatioita.

### Alkion etsiminen

Kun halutaan etsiä joukosta alkiota, lähdetään liikkeelle puun juuresta. Jos solmussa oleva alkio on pienempi kuin etsittävä alkio, siirrytään oikeaan lapseen. Jos solmussa oleva alkio on suurempi kuin etsittävä alkio, siirrytään vasempaan lapseen. Näin jatketaan, kunnes haluttu alkio on löytynyt tai solmulla ei ole lasta. Jälkimmäinen tapaus tarkoittaa, ettei etsittävää alkiota ole joukossa.

Esimerkiksi alkio $$7$$ voidaan löytää puusta kulkemalla seuraavaa reittiä:

![](../bhp_2.png)

### Alkion lisääminen

Joukkoon voidaan lisätä alkio etsimällä ensin alkiota joukosta. Jos alkio löytyy, sitä ei lisätä, koska sama alkio voi esiintyä joukossa vain kerran. Jos alkiota ei löydy, puuhun lisätään uusi solmu siihen kohtaan, johon haku olisi edennyt seuraavaksi.

Esimerkiksi alkio $$4$$ voidaan lisätä joukkoon seuraavan kuvan mukaisesti solmun $$3$$ oikeaksi lapseksi:

![](../bhp_3.png)

### Pienin alkio

Joukon pienin alkio löytyy lähtemällä liikkeelle juuresta ja etenemällä solmun vasempaan lapseen niin kauan, kuin tämä on mahdollista. Kun tämä ei ole enää mahdollista, pienin alkio on löytynyt.

### Suurin alkio

Tässä voidaan menetellä vastaavasti kuin pienimmän alkion etsimisessä, mutta joka vaiheessa siirrytään solmun oikeaan solmuun.

### Pienin suurempi alkio

Tavoitteena on löytää pienin alkio, joka on suurempi kuin $$x$$. Lähdetään liikkeelle juuresta ja siirrytään vasempaan lapseen aina, kun solmun alkio on suurempi kuin $$x$$, ja muuten oikeaan lapseen. Haku päättyy, kun siirtyminen ei ole mahdollista. Haluttu alkio on pienin alkiota $$x$$ suurempi alkio kaikista alkioista, joiden kautta reitti kulki.

### Suurin pienempi alkio

Tavoitteena on löytää suurin alkio, joka on pienempi kuin $$x$$. Tässä voidaan toimia käänteisesti edelliseen kohtaan verrattuna: siirrytään oikeaan lapseen aina, kun solmun alkio on pienempi kuin $$x$$. Haluttu alkio on suurin alkiota $$x$$ pienempi alkio reitillä olleista alkioista.

### Alkion poistaminen

Kun joukosta halutaan poistaa alkio, etsitään ensin alkiota vastaava solmu puusta. Tässä on kolme mahdollista tapausta:

* Solmulla ei ole lapsia. Tällöin solmu voidaan poistaa suoraan puusta.
* Solmulla on yksi lapsi. Tällöin voidaan poistaa solmu puusta ja siirtää sen tilalle solmun ainoa lapsi.
* Solmulla on kaksi lasta. Tällöin etsitään pienin alkiota suurempi alkio ja vaihdetaan keskenään näiden solmujen alkiot. Tämän jälkeen alkio on helppoa poistaa, koska sen solmulla on enintään yksi lapsi.

Seuraava kuva näyttää esimerkin, jossa halutaan poistaa alkio $$5$$. Koska solmulla on kaksi lasta, vaihdetaan ensin keskenään alkiot $$5$$ ja $$7$$. Tämän jälkeen alkio $$5$$ on helppoa poistaa, koska sillä ei ole lasta.

![](../bhp_4.png)

Huomaa, että kun solmulla on kaksi lasta ja etsitään solmu, jossa on pienin suurempi alkio, tällä solmulla ei voi olla vasenta lasta. Jos solmulla olisi vasen lapsi, siinä oleva alkio olisi pienempi mutta suurempi kuin poistettavan solmun alkio.

## Binäärihakupuu Pythonilla

Aletaan seuraavaksi toteuttaa binäärihakupuuta Pythonilla. Tavoitteena on saada aikaan luokka `TreeSet`, jota voidaan käyttää seuraavasti:

```python
s = TreeSet()

s.add(1)
s.add(2)
s.add(3)

print(2 in s) # True
print(4 in s) # False

print(s) # [1, 2, 3]
```

Tässä metodi `add` lisää alkion joukkoon, operaattori `in` ilmoittaa, onko alkio joukossa, ja joukon merkkijonoesityksenä on lista sen alkioista.

Seuraava luokka `Node` sisältää tiedon puussa olevasta solmusta:

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

Jokaiseen solmuun liittyy kolme tietoa: solmussa olevan alkion arvo (`value`) sekä viittaus solmun vasempaan ja oikeaan lapseen (`left` ja `right`).

Luokka `TreeSet` sisältää varsinaisen binäärihakupuun toteutuksen. Tässä on pohja luokalle:

```python
class TreeSet:
    def __init__(self):
        self.root = None
```

Metodi `__init__` luo muuttujan `root`, jossa on viittaus puun juureen. Alussa puussa ei ole yhtään solmua, minkä vuoksi `root` on `None`.

### Alkion lisääminen

Seuraava metodi `add` lisää alkion joukkoon:

```python
    def add(self, value, node=None):
        if node == None:
            if self.root == None:
                self.root = Node(value)
            else:
                self.add(value, self.root)
            return

        if node.value == value:
            return

        if node.value > value:
            if node.left == None:
                node.left = Node(value)
            else:
                self.add(value, node.left)

        if node.value < value:
            if node.right == None:
                node.right = Node(value)
            else:
                self.add(value, node.right)
```

Metodi on toteutettu niin, että `value` on lisättävä alkio ja `node` on käsiteltävä solmu. Kun metodia kutsutaan luokan ulkopuolelta, `node` on `None`, mikä tarkoittaa, että lisääminen alkaa puun juuresta.

Jos puu on tyhjä, alkio lisätään sen juureksi uuteen solmuun ja metodi päättyy. Muuten metodi lisää alkion puuhun rekursiivisesti.

Jos solmun alkio on sama kuin lisättävä alkio, metodi päättyy, koska alkio on jo lisätty. Jos alkio on suurempi, haku jatkuu vasemmalle, ja jos alkio on pienempi, haku jatkuu oikealle. Jos solmulla ei ole lasta, johon haun tulisi jatkua, uusi alkio lisätään kyseiseksi lapseksi ja metodi päättyy.

### Alkion etsiminen

Seuraava metodi `__contains__` tarkastaa, onko joukossa tiettyä alkiota. Metodia `__contains__` kutsutaan, kun koodissa on operaattori `in`.

```python
    def __contains__(self, value, node=None):
        if node == None:
            if self.root == None:
                return False
            return self.__contains__(value, self.root)

        if node.value == value:
            return True

        if node.value > value:
            if node.left == None:
                return False
            return self.__contains__(value, node.left)
        else:
            if node.right == None:
                return False
            return self.__contains__(value, node.right)
```

Edellisen metodin tapaan `value` on haettava alkio ja `node` on käsiteltävä solmu. Jos solmussa on haettava alkio, haku palauttaa `True`. Muuten haku liikkuu vasemmalle tai oikealle alkion suuruuden mukaan. Jos liikkuminen ei ole mahdollista, haku palauttaa `False`.

### Merkkijonoesitys

Seuraava metodi `__repr__` muodostaa joukon merkkijonoesityksen, joka sisältää joukon alkiot listana.

```python
    def __repr__(self):
        items = []
        self.traverse(self.root, items)
        return str(items)

    def traverse(self, node, items):
        if node == None:
            return
        self.traverse(node.left, items)
        items.append(node.value)
        self.traverse(node.right, items)
```

Metodi `__repr__` hyödyntää metodia `traverse`, joka käy läpi puun alkiot ja lisää ne listalle. Metodi käy ensin läpi vasemman alipuun, lisää sitten solmun alkion listalle ja käy sen jälkeen vielä läpi oikean alipuun. Tämän ansiosta lista sisältää lopuksi joukon alkiot suuruusjärjestyksessä.

### Muut operaatiot

Tässä toteutuksessa ei ole vielä metodeja pienimpien ja suurimpien alkioiden etsimiseen eikä alkion poistamiseen. Näiden metodien toteuttaminen kuuluu tämän viikon tehtäviin.

## Tasapainoisuus

Binäärihakupuun operaatiot käyvät läpi reittejä puun juuresta puun lehtiin. Tämän vuoksi puun tehokkuus riippuu siitä, miten pitkiä nämä reitit voivat olla. Pisimmän reitin pituus on yhtä suuri kuin puun korkeus $$h$$, joten binäärihakupuun operaatioiden tehokkuus voidaan ilmoittaa muodossa $$O(h)$$.

Binäärihakupuu ei sellaisenaan ole vielä tehokas tietorakenne, koska puun korkeus saattaa olla suuri. Esimerkiksi jos puuhun lisätään $$n$$ alkiota järjestyksessä $$1,2,\dots,n$$, kaikki alkiot menevät samaan ketjuun ja puun korkeus on $$n-1$$. Tällöin puun operaatiot vievät aikaa $$O(n)$$.

Kuitenkin binäärihakupuu voidaan toteuttaa niin, että alkiot jakautuvat tasaisesti puun eri puolille ja puun korkeus on aina luokkaa $$\log n$$. Tällöin puun operaatiot toimivat tehokkaasti ja vievät aikaa vain $$O(\log n)$$. Tällaista binäärihakupuuta kutsutaan _tasapainoiseksi_ (_balanced_).

Tasapainoinen binäärihakupuu sisältää usein ehtoja, jotka varmistavat, että puun korkeus ei kasva liian suureksi. Esimerkiksi _AVL-puu_ on tasapainoinen binäärihakupuu, jossa ehtona on, että solmun vasemman ja oikean alipuun korkeuksien ero saa olla enintään $$1$$. Tämän ehdon ansiosta puun korkeus on aina luokkaa $$\log n$$. Jotta ehto säilyisi voimassa, puun rakennetta voidaan muuttaa alipuiden kiertojen avulla alkion lisäämisen ja poistamisen jälkeen.

## Esimerkki: Asunnot

Seuraavassa on esimerkki tehtävästä, joka voidaan ratkaista tehokkaasti binäärihakupuun avulla:

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Saatavilla on $$n$$ asuntoa, joilla jokaisella on tietty pinta-ala. Sinun tulee palvella $$m$$ asunnonhakijaa, joista jokainen ilmoittaa, mikä on pienin riittävä asunnon pinta-ala. Sinun tulee käsitellä hakijat järjestyksessä vasemmalta oikealle ja antaa hakijalle pienin jäljellä oleva asunto, joka on riittävän suuri, tai ilmoittaa, ettei asuntoa ole saatavilla.

Esimerkiksi oletetaan että asuntojen koot ovat $$[30,40,50]$$ ja hakijat ilmoittavat vaatimukset $$[35,40,40,30]$$. Tässä tapauksessa haluttu tulos on $$[40,50,0,30]$$ seuraavan mukaisesti:

* Hakija 1 ilmoittaa pinta-alan $$35$$ ja saa asunnon, jonka pinta-ala on $$40$$.
* Hakija 2 ilmoittaa pinta-alan $$40$$ ja saa asunnon, jonka pinta-ala on $$50$$.
* Hakija 3 ilmoittaa pinta-alan $$40$$ eikä saa mitään asuntoa.
* Hakija 4 ilmoittaa pinta-alan $$30$$ ja saa asunnon, jonka pinta-ala on $$30$$.

</div>

Oletetaan, että käytössä on luokka `TreeSet`, jossa on seuraavat metodit:

* `add(x)`: lisää alkio `x` joukkoon
* `find_next(x)`: palauta pienin alkio, joka on suurempi kuin `x` (tai `None` jos alkiota ei ole olemassa)
* `remove(x)`: poista alkio `x` joukosta

Näiden metodien avulla tehtävä voidaan ratkaista seuraavasti:

```python
def find_apartments(sizes, requests):
    available = TreeSet()
    for size in sizes:
        available.add(size)
        
    result = []
    for request in requests:
        size = available.find_next(request - 1)
        if size == None:
            result.append(0)
        else:
            available.remove(size)
            result.append(size)
            
    return result        
```

Funktio luo joukon `available` ja lisää sinne kaikki saatavilla olevat asunnot. Tämän jälkeen funktio käy läpi asunnonhakijoiden pyynnöt ja lisää listalle `result` tiedot kunkin hakijan saamasta asunnosta.

Huomaa, että koska metodi `find_next` etsii pienimmän parametria suuremman alkion, sille annetaan parametriksi `request - 1`, koska on sallittua myös antaa asunto, jonka koko on tasan `request`.

Funktio vie aikaa $$O(n \log n + m \log n)$$ olettaen, että binäärihakupuu on tasapainoinen ja sen operaatiot vievät aikaa $$O(\log n)$$.

## Miksi ei Pythonissa?

Binäärihakupuu on saatavilla valmiina monissa ohjelmointikielissä, mutta se puuttuu Pythonin standardikirjastosta. Miksi näin on?

Syy lienee siinä, että Pythonin kehittäjien näkemyksen mukaan binäärihakupuu ei ole niin usein tarvittava tietorakenne, että sen tulisi olla kielen standardikirjastossa. Pythonissa keskeisessä asemassa ovat hajautukseen perustuvat tietorakenteet (`set` ja `dict`), jotka riittävät monissa tapauksissa.

Usein binäärihakupuun sijasta voidaan käyttää juuri hajautusta ja mahdollisesti lisäksi järjestämistä tai kekoa. Monissa tehtävissä yksi mahdollinen tehokas ratkaisu on käyttää binäärihakupuuta, mutta tehtävän voi ratkaista myös jotenkin muulla tavalla tehokkaasti ilman binäärihakupuuta.

Jos kuitenkin Pythonissa tarvitsee binäärihakupuuta, saatavilla on monia standardikirjaston ulkopuolisia toteutuksia. Näiden käyttäminen voi olla järkevämpää kuin itse toteutetun binäärihakupuun käyttäminen.

## Muiden kielten toteutukset

C++:ssa tietorakenteet ``std::set`` ja ``std::map`` toteuttavat binäärihakupuuhun perustuvan joukon ja hakemiston. Esimerkiksi seuraava koodi luo joukon, lisää sinne funktiolla `insert` sekä etsii funktiolla `upper_bound` pienimmän annettua alkiota suuremman alkion.

```cpp
std::set<int> items;

items.insert(1);
items.insert(3);
items.insert(6);
items.insert(8);

auto it = items.upper_bound(4);
std::cout << *it << "\n"; // 6
```

Javassa vastaavat tietorakenteet ovat `TreeSet` ja `TreeMap`. Esimerkiksi seuraava koodi vastaa äskeistä C++-koodia:

```java
TreeSet<Integer> items = new TreeSet<>();

items.add(1);
items.add(3);
items.add(6);
items.add(8);

int item = items.higher(4);
System.out.println(item); // 6
```

JavaScript noudattaa Pythonin linjaa siinä, että kielen standardikirjastossa ei ole binäärihakupuun toteutusta.
