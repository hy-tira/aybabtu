---
title: 3. Hajautus
slug: osa3
---

# 3. Hajautus

lol

## Joukon toteuttaminen

Tavallinen tilanne algoritmin suunnittelussa on, että haluamme lisätä alkioita joukkoon sekä tarkastaa, kuuluuko tietty alkio joukkoon. Yksi mahdollisuus on käyttää listaa seuraavaan tapaan:

```python
numbers = []

numbers.append(4)
numbers.append(2)
numbers.append(7)
numbers.append(8)

print(2 in numbers) # True
print(3 in numbers) # False
```

Tämän tavan ongelmana on, että listasta on hidasta tarkastaa, onko tietty alkio listalla. Listassa `in`-operaattori etsii alkiota listalta käymällä läpi koko listan sisällön, mikä on hidasta suuressa listassa.

Tässä tilanteessa parempi ratkaisu on käyttää tietorakennetta, joka on suunniteltu niin, että alkion kuulumisen tarkastaminen on nopeaa. Pythonissa tällainen tietorakenne on `set`-rakenne, jota voidaan käyttää seuraavasti:

```python
numbers = set()

numbers.add(4)
numbers.add(2)
numbers.add(7)
numbers.add(8)

print(2 in numbers) # True
print(3 in numbers) # False
```

Koodi on muuten samanlainen kuin listan kanssa, mutta metodin `append` sijasta käytetään metodia `add` alkion lisäämiseen.

Etuna `set`-rakenteessa on, että `in`-operaattori toimii tehokkaasti eli on nopeaa tarkastaa, kuuluuko tietty alkio joukkoon. Listassa `in`-operaattorin aikavaativuus on lineaarinen, mutta `set`-rakenteessa se on vakioaikainen.

Toisin kuin listassa, `set`-rakenteessa alkioihin ei voi viitata indekseillä, vaan voi vain tutkia alkion kuulumisen joukkoon. Tämän vuoksi ei ole mahdollista käyttää `[]`-syntaksia alkioiden käsittelyyn eikä seuraava koodi ole toimiva.

```python
numbers = set()

numbers.add(1)
numbers.add(2)
numbers.add(3)

print(numbers[0]) # ei toimi
```

Toinen ero on, että `set`-rakenteessa sama alkio voi esiintyä vain kerran. Jos alkio yritetään lisätä uudestaan, ei tapahdu mitään. Seuraava koodi esittelee asiaa:

```python
numbers = set()

numbers.add(5)
numbers.add(5)
numbers.add(5)

print(len(numbers)) # 1
```


## Esimerkki: Montako eri lukua?

<div class="note" markdown="1">

Annettuna on lista lukuja. Montako eri lukua listalla on?

Esimerkiksi kun lista on $$[3,1,2,1,5,2,2,3]$$, haluttu vastaus on $$4$$, koska eri luvut ovat $$1$$, $$2$$, $$3$$ ja $$5$$.

</div>

Tehdään aluksi hidas algoritmi, joka käy läpi listan luvut ja luo toisen listan, jossa jokainen luku esiintyy vain kerran. Seuraava funktio toteuttaa algoritmin:

```python
def count_distinct(numbers):
    seen = []
    for x in numbers:
        if x not in seen:
            seen.append(x)
    return len(seen)
```

Silmukassa lisätään luku listalle `seen`, jos lukua ei ole vielä listalla. Tämän ansiosta listan `seen` pituus funktion lopussa on sama kuin eri lukujen määrä. Funktio on toimiva mutta ei tehokas, koska `x not in seen` käy läpi koko listan `seen` eli siinä on piilotettu silmukka. Tämän vuoksi algoritmin aikavaativuus on $$O(n^2)$$.

Algoritmia on kuitenkin helppoa parantaa käyttämällä listan sijasta `set`-rakennetta. Tällöin algoritmi muuttuu näin:

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        if x not in seen:
            seen.add(x)
    return len(seen)
```

Tämä on pieni muutos algoritmiin, mutta sillä on suuri vaikutus tehokkuuteen. Muutoksen jälkeen `x not in seen` toimii tehokkaasti, koska `set`-rakenteesta on nopeaa tarkastaa alkion kuuluminen. Nyt algoritmi vie aikaa vain $$O(n)$$.

Koodia on mahdollista tiivistää, koska `set`-rakenne estää saman alkion lisäämisen uudestaan. Niinpä koodista voi poistaa tähän liittyvän tarkastuksen:

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        seen.add(x)
    return len(seen)
```

Itse asiassa koodia voi tiivistää vielä lisää, koska `set`-rakenteen voi luoda suoraan listan pohjalta. Tämän ansiosta riittää loppujen lopuksi yksi rivi koodia:

```python
def count_distinct(numbers):
    return len(set(numbers))
```

