---
title: 2. Lista
slug: osa2
---

# 2. Lista

Python-kielen perustietorakenne on _lista_, jossa jokaisella alkiolla on indeksi, jolla alkioon voidaan viitata. Esimerkiksi seuraava koodi luo listan, jossa on viisi alkiota, ja tulostaa sitten indekseissä `1` ja `4` olevat alkiot:

```python
numbers = [5, 2, 4, 6, 8]
print(numbers[1]) # 2
print(numbers[4]) # 8
```

Listan alkioiden määrää voidaan myös muuttaa listan luomisen jälkeen. Tavallinen tapa on käyttää `append`-metodia, joka lisää listan loppuun uuden alkion:

```python
numbers = []
numbers.append(1)
numbers.append(2)
numbers.append(3)
print(numbers) # [1, 2, 3]
```

Tässä luvussa tutustumme siihen, miten Pythonin lista on toteutettu sekä miten tehokkaita listan operaatiot ovat. Lopuksi käymme myös läpi vastaavia tietorakenteita muissa ohjelmointikielissä.

## Tieto muistissa

Tietokoneen muisti muodostuu peräkkäisistä muistipaikoista, joihin voidaan tallentaa tietoa. Jokaisella muistipaikalla on osoite, jolla siihen voidaan viitata. Muistiin tallennetaan ohjelman kaikkien muuttujien ja tietorakenteiden sisältö.

Tarkastellaan esimerkkinä seuraavaa Python-koodia:

```python
a = 7
b = -3
x = [1, 2, 3, 1, 2]
c = 99
```

Oletetaan, että koodissa määritellyt muuttujat ja lista on tallennettu muistiin osoitteesta 100 alkaen. Tässä tilanteessa muistin sisältö voisi näyttää suunnilleen seuraavalta:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110
7 | -3 | 1 | 2 | 3 | 1 | 2 | 0 | 0 | 0 | 99 |
`a` | `b` | `x` | | | | | | | | `c` |

Tässä muuttujan `a` sisältö on muistipaikat 100 ja muuttujan `b` sisältö on muistipaikassa 101. Listalle `x` on varattu muistipaikat 102–109, joista tällä hetkellä on käytössä muistipaikat 101–106, koska listalla on 5 alkiota. Muuttujan `c` sisältö on puolestaan muistipaikassa 110.

Listan alkiot on tallennettu peräkkäisiin muistipaikkoihin, minkä ansiosta on helppoa selvittää, missä kohdassa muistia tietty listan alkio sijaitsee. Tämä saadaan laskettua kaavalla `base + i`, missä `base` on listan ensimmäisen alkion osoite ja `i` on halutun alkion indeksi. Tässä tapauksessa esimerkiksi listan kohdassa 2 oleva alkio on osoitteessa 102 + 2 = 104.

Huomaa, että listalle on varattu enemmän muistia kuin on tarvetta, koska listalla on 5 alkiota mutta sille on varattu 8 muistipaikkaa. Listaan liittyy siis kaksi kokoa: listan todellinen pituus (tässä 5) sekä listalle varatun alueen pituus muistissa (tässä 8). Tämän ideana on varautua listan alkioiden määrän kasvamiseen, ja perehdymme asiaan tarkemmin myöhemmin tässä luvussa.

## Listan operaatiot

Tarkastellaan seuraavaksi listan operaatioiden tehokkuutta tilanteessa, jossa listaan on tallennettu $$n$$ alkiota.

### Indeksointi

Listan alkioita voidaan hakea tai muuttaa indeksin perusteella `[]`-syntaksilla.

```python
numbers = [4, 3, 7, 3, 2]
print(numbers[3]) # 7
numbers[2] = 5
```

Alkion hakeminen tai muuttaminen vie aikaa $$O(1)$$, koska alkiot ovat peräkkäin muistissa ja tietyn alkion sijainti voidaan laskea tehokkaasti.

### Pituus

Funktio `len` antaa listan pituuden eli alkioiden määrän.

```python
numbers = [4, 3, 7, 3, 2]
print(len(numbers)) # 5
```

Funktio vie aikaa $$O(1)$$, koska listan yhteyteen on tallennettu sen alkoiden määrä.

### Etsiminen

Operaattori `in` palauttaa arvon `True`, jos alkio on listalla, ja muuten arvon `False`. Metodi `index` etsii annetun alkion indeksin listalla, ja metodi `count` laskee, montako kertaa alkio esiintyy listalla.

```python
numbers = [4, 3, 7, 3, 2]
print(7 in numbers) # True
print(8 in numbers) # False
print(numbers.index(3)) # 1
print(numbers.count(3)) # 2
```

Kaikki nämä operaatiot vievät aikaa $$O(n)$$, koska niissä täytyy pahimmassa tapauksessa käydä läpi listan kaikki alkiot.

### Lisääminen loppuun

Metodi `append` lisää alkion listan loppuun. Tämän metodin aikavaativuus on _yleensä_ $$O(1)$$ olettaen, että listalle varatussa muistialueessa on tilaa uudelle alkiolle.

Tarkastellaan esimerkkinä seuraavaa tilannetta:

```python
a = 2
x = [1, 2, 3]
b = 9
```

Oletetaan, että tiedot on tallennettu muistiin seuraavasti:

100 | 101 | 102 | 103 | 104 | 105 |
2 | 1 | 2 | 3 | 0 | 9 |
`a` | `x` | | | | `b`

Tässä esimerkissä listalle on varattu neljä muistipaikkaa. Kun suoritetaan komento `x.append(4)`, uusi alkio voidaan lisätä helposti $$O(1)$$-ajassa listan loppuun:

100 | 101 | 102 | 103 | 104 | 105 |
2 | 1 | 2 | 3 | 4 | 9 |
`a` | `x` | | | | `b`

Mitä tapahtuu, jos tämän jälkeen suoritetaan `x.append(5)`? Alkiota `5` ei voida lisätä kohtaan 105, koska siellä on muuttujan `b` arvo, jota ei voida ylikirjoittaa. 

Ratkaisuna on varata muualta muistista suurempi muistialue listalle, kopioida sinne listan vanha sisältö sekä lisätä loppuun uusi alkio. Tässä tapauksessa voitaisiin sijoittaa uusi lista muistiin osoitteesta 106 alkaen ja varata sille 8 muistipaikkaa:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113
 2 | 0 | 0 | 0 | 0 | 9 | 1 | 2 | 3 | 4 | 5 | 0 | 0 | 0
`a` | | | | | `b` | `x`

Tämä operaatio vie aikaa $$O(n)$$, koska siinä täytyy varata listalle uusi muistialue sekä kopioida vanhan listan sisältö uuteen paikkaan.

### Lisääminen keskelle

Metodi `insert` lisää alkion annettuun listan kohtaan. Esimerkiksi seuraava koodi lisää alkion `5` indeksiin `1`:

```python
x = [1, 2, 3, 4, 5]
x.insert(1, 9)
print(x) # [1, 9, 2, 3, 4, 5]
```

Tässä operaatiossa kaikkia lisättävän alkion jälkeisiä alkioita täytyy siirtää eteenpäin muistissa, jotta uusi alkio saadaan lisättyä oikeaan paikkaan. Yllä olevassa koodissa aloitustilanne voisi olla seuraava:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 2 | 3 | 4 | 5 | 0 | 0 | 0
`x` |

Kun alkio `9` lisätään, muita alkioita täytyy siirtää seuraavasti:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 9 | 2 | 3 | 4 | 5 | 0 | 0
`x` |

Koska alkion lisääminen listan keskelle voi aiheuttaa monen alkion siirtämisen muistissa, tämän operaation aikavaativuus on $$O(n)$$.

### Poistaminen

Metodi `pop` poistaa alkion listasta. Jos metodia kutsutaan ilman parametria, se poistaa viimeisen alkion. Muuten metodi poistaa alkion parametrina annetusta indeksistä.

```python
x = [1, 2, 3, 4, 5]
x.pop()
print(x) # [1, 2, 3, 4]
x.pop(1)
print(x) # [1, 3, 4]
```

Kuten lisäämisessä, metodin tehokkuus riippuu poistettavan alkion sijainnista. Jos poistettava alkio on listan lopussa, aikaa kuluu $$O(1)$$, mutta jos poistettava alkio on listan keskellä, aikaa kuluu $$O(n)$$, koska poistettavan alkion jälkeisiä alkioita täytyy siirtää muistissa. Yllä olevassa esimerkissä aloitustilanne voisi olla:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 2 | 3 | 4 | 5 | 0 | 0 | 0
`x` |

Komennon `x.pop()` jälkeen tilanne on:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 2 | 3 | 4 | 0 | 0 | 0 | 0
`x` |

Komennon `x.pop(1)` jälkeen tilanne on:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 3 | 4 | 0 | 0 | 0 | 0 | 0
`x` |

Metodi `remove` poistaa annetun alkion ensimmäisen esiintymän listasta.

```python
x = [1, 2, 3, 1, 2, 3]
x.remove(3)
print(x) # [1, 2, 1, 2, 3]
```

Metodin aikavaativuus on $$O(n)$$, koska metodin täytyy ensin etsiä poistettava alkio listalta (samaan tapaan kuin metodissa `index`) ja sen jälkeen poistaa alkio ja siirtää sen jälkeen listassa tulevat alkiot.

### Uuden listan luonti

Seuraavassa koodissa listan `x` perusteella luodaan uusi lista `y`, johon valitaan indeksien `[2:6]` muodostama väli:

```python
x = [1, 2, 3, 4, 5, 6, 7, 8]
y = x[2:6]
print(y) # [3, 4, 5, 6]
```

Tämä operaatio vie aikaa $$O(n)$$, koska uuteen listaan kuuluvat alkiot täytyy kopioida uuteen paikkaan muistissa:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111
1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 3 | 4 | 5 | 6
`x` | | | | | | | | `y`

Seuraavassa koodissa listat `x` ja `y` liitetään yhteen uudeksi listaksi `z':

```python
x = [1, 2, 3, 4]
y = [5, 6]
z = x + y
print(z) # [1, 2, 3, 4, 5, 6]
```

Myös tämä operaatio vie aikaa $$O(n)$$, koska listojen alkiot täytyy kopioida uuteen paikkaan muistissa:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113
1 | 2 | 3 | 4 | 5 | 6 | 1 | 2 | 3 | 4 | 5 | 6 | 0 | 0
`x` | | | | `y` | | `z` |

### Yhteenveto

Seuraava taulukko näyttää yhteenvedon tässä käsiteltyjen listan operaatioiden tehokkuudesta:

Operaatio | Aikavaativuus
Indeksointi (`[]`) | $$O(1)$$
Pituuden laskeminen (`len`) | $$O(1)$$
Onko alkio listassa (`in`) | $$O(n)$$
Indeksin etsiminen (`index`) | $$O(n)$$
Määrän laskeminen (`count`) | $$O(n)$$
Lisääminen loppuun (`append`) | $$O(1)$$
Lisääminen keskelle (`insert`) | $$O(n)$$
Poistaminen lopusta (`pop`) | $$O(1)$$
Poistaminen keskeltä (`pop`) | $$O(n)$$
Etsiminen ja poistaminen (`delete`) | $$O(n)$$
Listan luominen indeksivälistä (`[:]`) | $$O(n)$$
Listan luominen yhdistämällä (`+`) | $$O(n)$$

Taulukosta näkee, että tehokkaita operaatioita listoilla ovat alkioiden indeksointi, pituuden laskeminen sekä alkion lisääminen listan loppuun ja alkion poistaminen listan lopusta. Tehokkuuden kannalta lista soveltuu käytettäväksi algoritmeissa, joissa tehdään paljonkin tällaisia operaatioita ja pieni määrä muita operaatioita.

## Listan koon muuttuminen

## Lista muissa kielissä
