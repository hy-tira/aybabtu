---
title: 2. Lista
slug: osa2
permalink: /:title/
---

# 2. Lista

_Lista_ (_list_) on monikäyttöinen tietorakenne, joka on Python-kielen perustietorakenne. Lista soveltuu usein ohjelmassa käsiteltävän tiedon tallentamiseen, mutta toisaalta on tilanteita, joissa listan sijasta kannattaa käyttää muita tietorakenteita.

Tutustumme tässä luvussa Pythonin listan toteutukseen ja ominaisuuksiin. Kiinnitämme erityisesti huomiota listan operaatioiden aikavaativuuteen: mitkä listan operaatiot ovat tehokkaita ja milloin listaa kannattaa käyttää.

## Lista muistissa

Tietokoneen muisti muodostuu peräkkäisistä muistipaikoista, joihin voidaan tallentaa tietoa. Jokaisella muistipaikalla on osoite, jolla siihen voidaan viitata. Muistiin tallennetaan tiedot, joita ohjelma käsittelee suorituksensa aikana.

Tarkastellaan esimerkkinä seuraavaa Python-ohjelmaa:

```python
a = 7
b = -3
c = [1, 2, 3, 1, 2]
d = 99
```

Oletetaan, että ohjelmassa määritellyt muuttujat ja lista on tallennettu muistiin osoitteesta 100 alkaen. Seuraavassa on yksinkertaistettu esitys siitä, miltä muistin sisältö voisi näyttää tässä tilanteessa:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110
7 | -3 | 1 | 2 | 3 | 1 | 2 | 0 | 0 | 0 | 99 |
`a` | `b` | `c` | | | | | | | | `d` |

Tässä muuttujan `a` sisältö on muistipaikassa 100 ja muuttujan `b` sisältö on muistipaikassa 101. Listalle `c` on varattu muistipaikat 102–109, joista tällä hetkellä on käytössä muistipaikat 101–106, koska listalla on 5 alkiota. Muuttujan `d` sisältö on puolestaan muistipaikassa 110.

Listan alkiot on tallennettu peräkkäisiin muistipaikkoihin, minkä ansiosta on helppoa selvittää, missä kohdassa muistia tietty listan alkio sijaitsee. Tämä saadaan laskettua kaavalla `base + i`, missä `base` on listan ensimmäisen alkion osoite ja `i` on halutun alkion indeksi. Tässä tapauksessa esimerkiksi listan kohdassa 2 oleva alkio on osoitteessa 102 + 2 = 104.

Huomaa, että listalle on varattu enemmän muistia kuin olisi tällä hetkellä tarvetta. Tämän ideana on varautua siihen, että listan alkioiden määrä saattaa kasvaa myöhemmin. Listaan liittyy siis kaksi kokoa: listan todellinen koko (tässä 5) sekä listalle muistista varatun alueen koko (tässä 8).

## Listan operaatiot

Pythonissa on monia valmiita operaatioita, joiden avulla voidaan käsitellä listoja. Tarkastellaan seuraavaksi näiden operaatioiden tehokkuutta aikavaativuuksien näkökulmasta olettaen, että listalla on $$n$$ alkiota.

Listan operaatioiden aikavaativuuksien tunteminen on tärkeää algoritmien suunnittelussa, koska niistä voi päätellä, mitä operaatioita voi käyttää tehokkaan algoritmin osana. Yleisimmät aikavaativuudet ovat:

* $$O(1)$$: operaatio toimii aina tehokkaasti riippumatta listan koosta
* $$O(n)$$: operaation tehokkuus riippuu listan koosta ja operaatio voi olla hidas, jos listan koko on suuri

### Indeksointi

Listan alkioita voidaan hakea tai muuttaa indeksin perusteella `[]`-syntaksilla.

```python
numbers = [4, 3, 7, 3, 2]
print(numbers[2]) # 7
numbers[2] = 5
print(numbers[2]) # 5
```

Alkion hakeminen tai muuttaminen vie aikaa $$O(1)$$, koska alkiot ovat peräkkäin muistissa ja tietyn alkion muistiosoite voidaan laskea tehokkaasti.

### Listan koko

Funktio `len` kertoo, montako alkiota listalla on:

```python
numbers = [4, 3, 7, 3, 2]
print(len(numbers)) # 5
```

Funktio vie aikaa $$O(1)$$, koska listan yhteyteen muistissa on tallennettu sen koko.

### Etsiminen

Operaattori `in` kertoo, onko alkio listalla. Metodi `index` antaa ensimmäisen indeksin, jossa alkio esiintyy listalla. Metodi `count` laskee, montako kertaa alkio esiintyy listalla.

```python
numbers = [4, 3, 7, 3, 2]

print(3 in numbers) # True
print(8 in numbers) # False

print(numbers.index(3)) # 1
print(numbers.count(3)) # 2
```

Kaikki nämä operaatiot vievät aikaa $$O(n)$$, koska niiden täytyy käydä läpi listan alkiot. Esimerkiksi operaattori `in`  vastaa logiikaltaan seuraavaa funktiota, joka käy läpi listan alkiot silmukan avulla:

```python
def in(values, x):
    for i in range(len(values)):
        if values[i] == x:
            return True
    return False
```

Huomaa, että operaatiot saattavat toimia tehokkaasti tietyissä tapauksissa. Esimerkiksi jos etsittävä alkio on listan alussa, operaattori `in` toimii nopeasti, koska se voi lopettaa listan läpikäynnin heti alkion löydyttyä. Kuitenkin pahimmassa tapauksessa alkio ei esiinny listalla ja koko lista täytyy käydä läpi.

### Lisääminen loppuun

Metodi `append` lisää alkion listan loppuun. Tämän metodin aikavaativuus on _yleensä_ $$O(1)$$ olettaen, että listalle varatussa muistialueessa on tilaa uudelle alkiolle.

Tarkastellaan esimerkkinä seuraavaa tilannetta:

```python
a = 2
x = [1, 2, 3]
b = 9
```

Oletetaan, että tiedot on tallennettu muistiin seuraavasti:

100 | 101 | 102 | 103 | 104 | 105 |
2 | 1 | 2 | 3 | 0 | 9 |
`a` | `x` | | | | `b`

Tässä esimerkissä listalle on varattu neljä muistipaikkaa. Kun suoritetaan komento `x.append(4)`, uusi alkio voidaan lisätä helposti $$O(1)$$-ajassa listan loppuun:

100 | 101 | 102 | 103 | 104 | 105 |
2 | 1 | 2 | 3 | 4 | 9 |
`a` | `x` | | | | `b`

Mitä tapahtuu, jos tämän jälkeen suoritetaan komento `x.append(5)`? Alkiota `5` ei voida tallentaa osoitteeseen 105, koska tämä muistipaikka on varattu muuttujan `b` arvolle, jota ei voida ylikirjoittaa. 

Ratkaisuna on varata muualta muistista suurempi muistialue listalle, kopioida sinne listan vanha sisältö sekä lisätä loppuun uusi alkio. Tässä tapauksessa voitaisiin sijoittaa uusi lista muistiin osoitteesta 106 alkaen:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113
 2 | 0 | 0 | 0 | 0 | 9 | 1 | 2 | 3 | 4 | 5 | 0 | 0 | 0
`a` | | | | | `b` | `x`

Tämä operaatio vie aikaa $$O(n)$$, koska siinä täytyy kopioida listan sisältö vanhasta paikasta uuteen paikkaan.

Vaikka alkion lisääminen listan loppuun vie välillä aikaa $$O(n)$$, operaatio vie kuitenkin _keskimäärin_ aikaa vain $$O(1)$$, kun lista on toteutettu sopivasti ja $$O(n)$$-operaatio tapahtuu riittävän harvoin. Analysoimme tätä tilannetta tarkemmin myöhemmin tässä luvussa.

### Lisääminen keskelle

Metodi `insert` lisää alkion annettuun listan kohtaan. Esimerkiksi seuraava koodi lisää alkion `5` indeksiin `1`:

```python
x = [1, 2, 3, 4, 5]
x.insert(1, 9)
print(x) # [1, 9, 2, 3, 4, 5]
```

Tässä operaatiossa kaikkia lisättävän alkion jälkeisiä alkioita täytyy siirtää eteenpäin muistissa, jotta uusi alkio saadaan lisättyä oikeaan paikkaan. Yllä olevassa koodissa aloitustilanne voisi olla seuraava:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 2 | 3 | 4 | 5 | 0 | 0 | 0
`x` |

Kun alkio `9` lisätään, muita alkioita täytyy siirtää seuraavasti:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 9 | 2 | 3 | 4 | 5 | 0 | 0
`x` |

Koska alkion lisääminen listan keskelle voi aiheuttaa monen alkion siirtämisen muistissa, tämän operaation pahimman tapauksen aikavaativuus on $$O(n)$$. Operaatio toimii kuitenkin tehokkaasti, jos alkio lisätään listan loppuun.

### Poistaminen

Metodi `pop` poistaa alkion listasta. Jos metodia kutsutaan ilman parametria, se poistaa listan viimeisen alkion. Muuten metodi poistaa alkion parametrina annetusta indeksistä.

```python
x = [1, 2, 3, 4, 5]
x.pop()
print(x) # [1, 2, 3, 4]
x.pop(1)
print(x) # [1, 3, 4]
```

Kuten lisäämisessä, metodin tehokkuus riippuu poistettavan alkion sijainnista. Jos poistettava alkio on listan lopussa, aikaa kuluu $$O(1)$$, mutta jos poistettava alkio on listan keskellä, aikaa kuluu $$O(n)$$, koska poistettavan alkion jälkeisiä alkioita täytyy siirtää muistissa. Yllä olevassa esimerkissä aloitustilanne voisi olla:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 2 | 3 | 4 | 5 | 0 | 0 | 0
`x` |

Komennon `x.pop()` jälkeen tilanne on:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 2 | 3 | 4 | 0 | 0 | 0 | 0
`x` |

Komennon `x.pop(1)` jälkeen tilanne on:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
1 | 3 | 4 | 0 | 0 | 0 | 0 | 0
`x` |

Metodi `remove` poistaa annetun alkion ensimmäisen esiintymän listasta.

```python
x = [1, 2, 3, 1, 2, 3]
x.remove(3)
print(x) # [1, 2, 1, 2, 3]
```

Metodin aikavaativuus on $$O(n)$$, koska metodin täytyy ensin etsiä poistettava alkio listalta (samaan tapaan kuin metodissa `index`) ja sen jälkeen poistaa alkio ja siirtää sen jälkeen listassa tulevat alkiot.

### Uuden listan luonti

Seuraavassa koodissa listan `x` perusteella luodaan uusi lista `y`, johon valitaan indeksien `[2:6]` muodostama väli:

```python
x = [1, 2, 3, 4, 5, 6, 7, 8]
y = x[2:6]
print(y) # [3, 4, 5, 6]
```

Tämä operaatio vie aikaa $$O(n)$$, koska uuteen listaan kuuluvat alkiot täytyy kopioida uuteen paikkaan muistissa:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111
1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 3 | 4 | 5 | 6
`x` | | | | | | | | `y`

Seuraavassa koodissa listat `x` ja `y` liitetään yhteen uudeksi listaksi `z`:

```python
x = [1, 2, 3, 4]
y = [5, 6]
z = x + y
print(z) # [1, 2, 3, 4, 5, 6]
```

Myös tämä operaatio vie aikaa $$O(n)$$, koska listojen alkiot täytyy kopioida uuteen paikkaan muistissa:

100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113
1 | 2 | 3 | 4 | 5 | 6 | 1 | 2 | 3 | 4 | 5 | 6 | 0 | 0
`x` | | | | `y` | | `z` |

### Yhteenveto

Seuraava taulukko näyttää yhteenvedon tässä käsiteltyjen listan operaatioiden tehokkuudesta:

Operaatio | Aikavaativuus
--- | ---
Indeksointi (`[]`) | $$O(1)$$
Pituuden laskeminen (`len`) | $$O(1)$$
Onko alkio listassa (`in`) | $$O(n)$$
Indeksin etsiminen (`index`) | $$O(n)$$
Määrän laskeminen (`count`) | $$O(n)$$
Lisääminen loppuun (`append`) | $$O(1)$$
Lisääminen keskelle (`insert`) | $$O(n)$$
Poistaminen lopusta (`pop`) | $$O(1)$$
Poistaminen keskeltä (`pop`) | $$O(n)$$
Etsiminen ja poistaminen (`delete`) | $$O(n)$$
Listan luominen indeksivälistä (`[:]`) | $$O(n)$$
Listan luominen yhdistämällä (`+`) | $$O(n)$$

Taulukosta näkee, että tehokkaita operaatioita listoilla ovat alkioiden indeksointi, pituuden laskeminen sekä alkion lisääminen listan loppuun ja alkion poistaminen listan lopusta. Lista soveltuu erityisesti käytettäväksi algoritmeissa, joissa tehdään enimmäkseen tällaisia operaatioita ja vähän muita operaatioita.

## Listan koon muuttuminen

Kun listan loppuun lisätään alkio metodilla `append`, aikaa kuluu $$O(1)$$ tai $$O(n)$$ riippuen siitä, voidaanko uusi alkio sijoittaa suoraan varatun muistialueen loppuun vai tuleeko ensin varata uusi muistialue ja siirtää listan vanha sisältö sinne.

Vaikka alkion lisääminen vie välillä aikaa $$O(n)$$, voidaan osoittaa, että aikaa kuluu _keskimäärin_ vain $$O(1)$$, jos uuden muistialueen varaaminen toteutetaan sopivalla tavalla. Yksi mahdollinen tapa on _kaksinkertaistaa_ muistialueen koko aina, kun muistia varataan lisää.

Tarkastellaan tilannetta, jossa listalle on lisätty yhteensä $$n$$ alkiota ja listalle on juuri varattu uusi muistialue. Tässä tilanteessa $$n$$ alkiota on siirretty kerran, $$n/2$$ alkiota on siirretty kahdesti, $$n/4$$ alkiota on siirretty kolmesti jne., joten yhteensä siirrettyjen alkioiden määrä on

$$n+n/2+n/4+n/8+\dots = O(n).$$

Koska listalla on yhteensä $$n$$ alkiota ja kaikkien siirtojen määrä on $$O(n)$$, kunkin alkion lisääminen on vienyt _keskimäärin_ $$O(1)$$ aikaa.

Yleisemmin jos varatun alueen koko $$c$$-kertaistetaan, siirrettyjen alkioiden määrä on

$$n+n/c+n/c^2+n/c^3+\dots = O(n),$$

kun $$c$$ on mikä tahansa vakio, joka on suurempi kuin $$1$$.

Pythonin referenssitoteutuksessa (CPython) vakio $$c$$ on noin $$9/8$$, mikä tarkoittaa, että muistialueen koko kasvaa melko hitaasti. Mitä hitaammin muistialueen koko kasvaa, sitä vähemmän ylimääräistä muistia listat vievät, mutta toisaalta sitä useammin listoilla olevia alkioita täytyy kopioida muistissa.

## Listat muissa kielissä

Tässä luvussa käsitelty listarakenne tunnetaan yleisemmin nimellä _taulukkolista_ (_array list_) tai _dynaaminen taulukko_ (_dynamic array_).

Pythonia matalamman tason kielissä (kuten C++ ja Java) perustietorakenne on yleensä _taulukko_ (_array_). Kuten Pythonin listassa, taulukon alkiot on numeroitu $$0 \dots n-1$$ ja niitä voi indeksoida tehokkaasti, mutta taulukon koon muuttaminen ei ole mahdollista taulukon luomisen jälkeen. Tämä helpottaa muistinkäsittelyä, koska taulukolle voi varata sopivan määrän muistia heti luontihetkellä.

Kuitenkin taulukon lisäksi näissä kielissä on saatavilla Pythonin listan kaltainen taulukkolista. C++:ssa tällainen tietorakenne on `vector`:

```cpp
vector<int> numbers;
numbers.push_back(1);
numbers.push_back(2);
numbers.push_back(3);
```
Javassa puolestaan tietorakenne `ArrayList` toteuttaa taulukkolistan:

```java
ArrayList<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
```

JavaScriptin perustietorakenne on nimeltään taulukko, mutta se on todellisuudessa taulukkolista, koska sen kokoa pystyy muuttamaan:

```js
numbers = [];
numbers.push(1);
numbers.push(2);
numbers.push(3);
```

Kaikissa näissä listarakenteissa on tehokasta käsitellä alkioita indeksin perusteella sekä lisätä alkio listan loppuun ja poistaa alkio listan lopusta.

Toinen yleisesti tunnettu listarakenne on _linkitetty lista_ (_linked list_), johon tutustumme myöhemmin kurssilla. Linkitetyssä listassa alkiot viittaavat toisiinsa eivätkä ne ole peräkkäin muistissa. Tämän vuoksi linkitetyn listan tehokkuus on yleensä taulukkolistaa huonompi eikä linkitetylle listalle ole usein tarvetta käytännössä.
