---
title: 3. Tehokkaat algoritmit
slug: osa3
permalink: /:title/
---

# 3. Tehokkaat algoritmit

Tässä ja kahdessa seuraavassa luvussa tutustumme tehokkaiden algoritmien suunnitteluun. Tavoitteemme on saada aikaan algoritmeja, jotka toimivat tehokkaasti myös silloin, kun syötteen koko $$n$$ on suuri.

Tavallinen tilanne algoritmien suunnittelussa on, että on helppoa laatia suoraviivainen algoritmi, joka ratkaisee tehtävän kahdella silmukalla ajassa $$O(n^2)$$. Tällaista algoritmia voidaan kutsua _raa'an voiman_ (_brute force_) algoritmiksi. Tämä ei kuitenkaan riitä $$n$$:n ollessa suuri, vaan tarvitaan tehokkaampi algoritmi.

Käytännössä tehokkaan algoritmin aikavaativuus on usein $$O(n)$$ tai $$O(n \log n)$$. Tutustumme ensin $$O(n)$$-algoritmeihin, jotka käyvät syötteen läpi yhdellä silmukalla ja pitävät muistissa sopivalla tavalla valittua tietoa. Aikavaativuus $$O(n \log n)$$ liittyy usein järjestämiseen, jota käsittelemme luvussa 5.


## Esimerkki: Osakekauppa

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Annettuna on osakkeen hinta $$n$$ päivän ajalta. Tehtäväsi on selvittää, mikä olisi ollut suurin mahdollinen tuotto, jos olisit ostanut osakkeen yhtenä päivänä ja myynyt sen toisena päivänä.

Tarkastellaan esimerkkinä seuraavaa tilannetta:

Päivä | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
Hinta | 3 | 7 | 5 | 1 | 4 | 6 | 2 | 3

Tässä suurin mahdollinen tuotto saadaan ostamalla osake päivänä 3 ja myymällä se päivänä 5. Tuotoksi tulee 6 – 1 = 5.

</div>

Suoraviivainen algoritmi tehtävän ratkaisemiseen on käydä läpi kaikki vaihtoehdot osakkeen ostopäivän ja myyntipäivän valintaan kahdella silmukalla. Seuraava funktio `best_profit` toteuttaa algoritmin:

```python
def best_profit(prices):
    n = len(prices)
    best = 0
    for i in range(n):
        for j in range(i + 1, n):
            best = max(best, prices[j] - prices[i])
    return best
```

Ideana on, että muuttuja `i` valitsee myyntipäivän ja muuttuja `j` valitsee ostopäivän. Jokaiselle valinnalle lasketaan näin saatava tuotto osakekaupasta, ja muuttuja `best` pitää muistissa parasta tuottoa. Tämä on toimiva algoritmi, mutta ongelmana on, että algoritmin aikavaativuus on $$O(n^2)$$ eli se on hidas, kun $$n$$ on suuri. Algoritmia tulisi tehostaa niin, että siinä ei ole kahta silmukkaa vaan vain yksi silmukka.

Mietitään nyt, millainen algoritmin tulisi olla, jotta siinä olisi vain yksi silmukka. Kun olemme tietyn päivän kohdalla, miten suuri voitto on mahdollinen, jos myymme osakkeen kyseisenä päivänä? Voitto on suurin silloin, kun olemme ostaneet osakkeen aiemmin mahdollisimman halvalla. Niinpä meidän kannattaa valita ostohinnaksi osakkeen halvin hinta kyseiseen päivään mennessä.

Voimme toteuttaa tällaisen algoritmin seuraavasti:

```python
def best_profit(prices):
    n = len(prices)
    best = 0
    for i in range(n):
        min_price = min(prices[0:i+1])
        best = max(best, prices[i] - min_price)
    return best
```

Ideana on laskea silmukassa muuttujaan `min_price` osakkeen halvin hinta päivään `i` mennessä. Tämä on toteutettu hakemalla pienin alkio `min`-funktiolla listan alkuosassa `prices[0:i+1]`. Tämän jälkeen saamme laskettua kaavalla `prices[i] - min_price` voiton, kun myymme osakkeen päivänä `i`.

Tämä on toimiva algoritmi ja siinä on vain yksi silmukka, mutta algoritmi ei ole vielä tehokas. Ongelmana on, että muuttujan `min_price` laskeminen on hidasta silmukassa, koska `min`-funktio käy läpi listan `prices` alkuosan. Tämä vie aikaa $$O(n)$$, minkä vuoksi algoritmin aikavaativuus on edelleen $$O(n)$$.

Voimme kuitenkin korjata ongelman seuraavasti:

```python
def best_profit(prices):
    n = len(prices)
    best = 0
    min_price = prices[0]
    for i in range(n):
        min_price = min(min_price, prices[i])
        best = max(best, prices[i] - min_price)
    return best
```

Nyt muuttujaa `min_price` ei lasketa tyhjästä silmukan joka kierroksella, vaan uusi arvo lasketaan tehokkaasti edellisen arvon perusteella. Tämän muutoksen ansiosta silmukan jokainen kierros vie aikaa $$O(1)$$, jolloin algoritmin aikavaativuus on $$O(n)$$ ja algoritmi toimii tehokkaasti.

Huomaa, että funktion `min` käyttäminen voi olla sekä hidasta että tehokasta. Jos funktiolla haetaan listan pienin alkio, tämä on hidasta. Jos kuitenkin funktiolla valitaan pienempi kahdesta arvosta, tämä on tehokasta.

## Esimerkki: Bittijono

<div class="note" markdown="1">
Annettuna on bittijono, joka muodostuu merkeistä `0` ja `1`. Monellako tavalla voit valita bittijonosta kaksi kohtaa niin, että vasemmassa kohdassa on bitti `0` ja oikeassa kohdassa on bitti `1`?

Tarkastellaan esimerkkinä seuraavaa tilannetta:

Kohta | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
Bitti | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 |

Tässä tilanteessa mahdollisia tapoja on 14.

</div>

Suoraviivainen tapa ratkaista tehtävä on käydä läpi kaikki tavat valita vasen ja oikea kohta ja laskea, monessako kohdassa vasen bitti on `0` ja oikea bitti on `1`:

```python
def count_ways(bits):
    n = len(bits)
    result = 0
    for i in range(n):
        for j in range(i + 1, n):
            if bits[i] == '0' and bits[j] == '1':
                result += 1
    return result
```

Tässä ongelmana on jälleen, että aikavaativuus on $$O(n^2)$$ eli algoritmi on liian hidas.

Mietitään, miten selviäisimme yhdellä silmukalla. Kuten osakkeen hinnan laskemisessa, tässäkin tehtävässä hyvä lähestymistapa on käsitellä jokaisessa kohdassa kyseiseen kohtaan päättyvät ratkaisut. Tarkemmin voimme koettaa laskea kussakin bittijonon kohdassa `i` tehokkaasti tavat, joissa oikea bitti `1` on kohdassa `i` ja vasen bitti `0` on ennen kohtaa `i`.

Jos kohdassa `i` on bitti `1`, tässä kohdassa voi olla oikea kohta. Tässä tapauksessa vasen kohta voi olla mikä tahansa kohta ennen kohtaa `i`, jossa on bitti `0`. Niinpä saamme aikaan tehokkaan algoritmin, kun pidämme muistissa, montako bittiä `0` on tullut vastaan silmukan aikana. Voimme toteuttaa algoritmin näin:

```python
def count_ways(bits):
    n = len(bits)
    result = 0
    zeros = 0
    for i in range(n):
        if bits[i] == '0':
            zeros += 1
        if bits[i] == '1':
            result += zeros
    return result
```

Silmukan sisällä suoritettava koodi riippuu siitä, onko bitti `0` vai `1`. Jos bitti on `0`, kasvatetaan muuttujan `zeros` arvoa. Tämän avulla joka kohdassa tiedetään, montako bittiä `0` on tullut vastaan tähän mennessä. Jos taas bitti on `1`, lisätään muuttujaan `result` muuttujan `zeros` arvo. Tämä laskee tehokkaasti mukaan tulokseen kaikki tavat, joissa oikea bitti on kohdassa `i`.

Algoritmissa on yksi silmukka, joka käy syötteen läpi, ja silmukan sisällä olevan koodin aikavaativuus on $$O(1)$$. Tämän ansiosta algoritmin aikavaativuus on $$O(n)$$ ja se toimii tehokkaasti.
