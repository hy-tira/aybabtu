---
title: 10. Dynaaminen ohjelmointi
slug: osa10
sections:
  - Optimiratkaisun haku
  - Optimiratkaisun muodostus
  - Ratkaisujen laskeminen
---

# 10. Dynaaminen ohjelmointi

Dynaaminen ohjelmointi on algoritmitekniikka, jonka avulla voidaan ratkaista tehokkaasti monia hakuongelmia. Tutustumme tässä luvussa dynaamiseen ohjelmointiin seuraavan tehtävän kautta:

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Käytössäsi on rajaton määrä kolikkoja, joiden arvot annetaan listassa. Tavoitteena on muodostaa kolikoista summa $$x$$.

1. _Optimiratkaisun haku_: Montako kolikkoa tarvitaan vähintään summan muodostamiseen?
2. _Optimiratkaisun muodostus_: Anna esimerkki ratkaisusta, jossa on pienin määrä kolikkoja.
3. _Ratkaisujen laskeminen_: Kuinka monta eri tapaa on muodostaa summa kolikoista?

Esimerkiksi kun kolikot ovat $$[1,2,5]$$ ja $$x=13$$, vastaukset ovat:

1. Pienin määrä kolikoita on $$4$$.
2. Pienin ratkaisu saadaan valitsemalla kolikot $$[1,2,5,5]$$.
3. Erilaisia tapoja on $$634$$ (kuten $$[1,2,5,5]$$, $$[2,2,2,2,5]$$ ja $$[1,1,1,5,5]$$).

</div>

Edellisessä luvussa ratkaisimme tehtävän tehokkaasti ahneella algoritmilla tapauksessa, jossa kolikot ovat $$[1,2,5]$$. Ahne algoritmi ei kuitenkaan toimi kaikissa tapauksissa: esimerkiksi jos kolikot ovat $$[1,4,5]$$, algoritmi voi antaa väärän vastauksen. Lisäksi ahneella algoritmilla ei ole mahdollista ratkaista tehtävän kohtaa 3, jossa tulee laskea kaikkien tapojen määrä.

Näemme seuraavaksi, miten saamme ratkaistua tehtävän kaikki kohdat tehokkaasti dynaamisen ohjelmoinnin avulla. Tässä tehtävässä esille tulevia ideoita pystyy käyttämään myös muiden tehtävien ratkaisemisessa.

## Optimiratkaisun haku

Dynaamisen ohjelmoinnin käyttäminen vaatii, että ongelma voidaan ratkaista saman ongelmien pienempien tapausten eli _osaongelmien_ avulla. Kun halutaan etsiä pienin määrä kolikkoja summan $$x$$ muodostamiseen, voimme käyttää osaongelmina tapauksia, joissa tavoitteena oleva summa on pienempi kuin $$x$$.

Voimme lähteä muodostamaan summaa $$x$$ valitsemalla ensimmäisen summaan kuuluvan kolikon. Esimerkiksi jos $$x=13$$ ja kolikot ovat $$[1,2,5]$$, vaihtoehtoja on kolme:

* Valitaan kolikko $$1$$. Tämän jälkeen tulee muodostaa summa $$x=12$$.
* Valitaan kolikko $$2$$. Tämän jälkeen tulee muodostaa summa $$x=11$$.
* Valitaan kolikko $$5$$. Tämän jälkeen tulee muodostaa summa $$x=8$$.

Jos tiedossa on pienin kolikoiden määrä tapauksille $$x=8$$, $$x=11$$ ja $$x=12$$, saamme pienimmän kolikoiden määrän tapaukselle $$x=13$$ valitsemalla näistä pienimmän ja lisäämällä tulokseen yhden. Niinpä seuraavaksi tulee ratkaista kolme osaongelmaa $$x=8$$, $$x=11$$ ja $$x=12$$. Nämä osaongelmat voi ratkaista samalla tavalla jakamalla ne edelleen pienempiin osaongelmiin.

Käytännössä voimme ratkaista tehtävän tällä idealla seuraavasti:

```python
coins = [1, 2, 5]

def min_coins(x):
    if x == 0:
        return 0

    if x < 0:
        return float("inf")

    result = float("inf")
    for coin in coins:
        result = min(result, min_coins(x - coin) + 1)
    return result
```

Funktion `min_coins` tehtävänä on palauttaa pienin määrä kolikkoja, joilla voidaan muodostaa summa $$x$$. Jos $$x=0$$, funktio palauttaa arvon $$0$$, koska tällöin ei tarvita mitään kolikkoja. Jos $$x<0$$, funktio palauttaa arvon $$\infty$$ (ääretön), joka kuvastaa sitä, että ratkaisua ei ole olemassa, jos summa on negatiivinen.

Viimeisenä tapauksena on $$x>0$$, jolloin funktio etsii ratkaisun rekursiivisesti. Funktio käy läpi listassa `coins` olevat kolikot ja laskee pienimmän tarvittavan kolikoiden määrän muuttujaan `result`, jonka alkuarvona on ääretön. Jokaisen kolikon `coin` kohdalla funktio laskee, montako kolikkoa tarvitaan vielä, jos kolikko `coin` valitaan mukaan. Lisäämällä tähän tulokseen yksi saadaan pienin kolikkojen määrä tapauksessa, jossa kolikko valitaan.

Funktiota voidaan käyttää näin:

```python
print(min_coins(13)) # 4
```

Tämä funktio on toimiva mutta ei vielä tehokas, koska funktio käy läpi rekursiivisesti suuren määrän ratkaisuja. Esimerkiksi tapauksessa $$x=13$$ funktiota kutsutaan yhteensä $$2698$$ kertaa laskennan aikana. Funktiota voidaan kuitenkin tehostaa ottamalla huomioon, että osaongelmien määrä on pieni eli on vain pieni määrä _erilaisia_ parametreja, joilla funktiota kutsutaan. Tämä on idea, johon dynaaminen ohjelmointi perustuu.

Voimme tehostaa funktiota ottamalla käyttöön tietorakenteen, johon tallennetaan funktion arvoja eri parametreilla. Seuraavassa dynaamisen ohjelmoinnin koodissa tällainen tietorakenne on sanakirja `cache`.

```python
coins = [1, 2, 5]
cache = {}

def min_coins(x):
    if x == 0:
        return 0

    if x < 0:
        return float("inf")
        
    if x in cache:
        return cache[x]

    result = float("inf")
    for coin in coins:
        result = min(result, min_coins(x - coin) + 1)
    cache[x] = result
    return result
```

Muutoksena alkuperäiseen versioon funktio tallentaa rekursiivisesti lasketut tulokset sanakirjaan `cache`. Lisäksi ennen rekursion aloittamista funktio tarkastaa, onko tulos lisätty aiemmin sanakirjaan `cache`. Jos on, funktio palauttaa sen suoraan eikä tulosta tarvitse laskea uudestaan.

Dynaaminen ohjelmointi tehostaa funktion toimintaa merkittävästi. Esimerkiksi tapauksessa $$x=13$$ tehostettua funktiota kutsutaan vain $$40$$ kertaa, kun taas alkuperäistä funktiota kutsutaan $$2698$$ kertaa. Seuraava taulukko vertailee tarkemmin alkuperäisen ja tehostetun funktion kutsujen määrää:

Summa $$x$$ | Alkuperäinen funktio | Tehostettu funktio
-- | -- | --
5 | $$37$$ kutsua | $$16$$ kutsua
10 | $$544$$ kutsua | $$31$$ kutsua
15 | $$7843$$ kutsua | $$46$$ kutsua
20 | $$112981$$ kutsua | $$61$$ kutsua
25 | $$1627441$$ kutsua | $$76$$ kutsua
30 | $$23442475$$ kutsua | $$91$$ kutsua
35 | -- | $$106$$ kutsua
40 | -- | $$121$$ kutsua
45 | -- | $$136$$ kutsua
50 | -- | $$151$$ kutsua

Kutsujen määrä heijastuu suoraan funktioiden ajankäyttöön. Alkuperäinen funktio käyttää tapaukseen $$x=30$$ lähes kymmenen sekuntia eikä suurempien tapausten laskeminen ole mahdollista mielekkäässä ajassa, kun taas tehostettu funktio laskee kaikki tapaukset silmänräpäyksessä.

Huomaa, että koska algoritmi käy läpi kaikki tavat valita kolikoita, se antaa oikean vastauksen riippumatta kolikoista. Niinpä algoritmi toimii oikein myös kolikoilla $$[1,4,5]$$ ja kaikissa muissa tapauksissa, joissa ahne algoritmi antaa väärän vastauksen. Dynaamisen ohjelmoinnin hienoutena on, että haku voi käydä läpi kaikki yhdistelmät mutta se toimii kuitenkin tehokkaasti.

## Optimiratkaisun muodostus

Laajennetaan seuraavaksi dynaamisen ohjelmoinnin algoritmia niin, että se etsii pienimpään ratkaisuun tarvittavat kolikot. Esimerkiksi kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, algoritmin tulisi näyttää ratkaisu $$[1,2,5,5]$$ eikä vain ilmoittaa, että pienimmässä ratkaisussa on $$4$$ kolikkoa.

Ratkaisun muodostaminen voidaan toteuttaa tallentamalla enemmän tietoa haun aikana. Seuraavassa funktiossa käytössä on sanakirja `best_choice`, johon tallennetaan kullekin summalle $$x$$ tieto, mikä kolikko tulee valita ensimmäisenä summaa muodostaessa.

```python
coins = [1, 2, 5]
cache = {}
best_choice = {}

def min_coins(x):
    if x == 0:
        return 0

    if x < 0:
        return float("inf")
        
    if x in cache:
        return cache[x]

    result = float("inf")
    for coin in coins:
        new_result = min_coins(x - coin) + 1
        if new_result < result:
            result = new_result
            best_choice[x] = coin
    cache[x] = result
    return result
```

Funktio päivittää sanakirjaa `best_choice` aina, kun `result` muuttuu silmukan aikana. Tämän ansiosta silmukan päätteeksi sanakirja sisältää tiedon kolikosta, joka tulee valita ensimmäisenä muodostaessa summaa $$x$$. Sanakirjaa voidaan hyödyntää näin kolikoiden etsimiseen:

```python
def find_coins(x):
    solution = []
    while x > 0:
        coin = best_choice[x]
        solution.append(coin)
        x -= coin
    return solution
```

Funktio `find_coins` muodostaa sanakirjan `best_choice` avulla listan, jossa on summaan $$x$$ tarvittavat kolikot. Funktio poistaa summasta $$x$$ kolikoita yksi kerrallaan, kunnes summa on lopuksi $$0$$, ja lisää kolikot samalla listaan.

Näiden funktioiden avulla voidaan muodostaa pienin ratkaisu kutsumalla ensin funktiota `min_coins` ja sitten `find_coins`. Esimerkiksi pienin ratkaisu tapauksessa $$x=13$$ voidaan etsiä seuraavasti:

```python
print(min_coins(13)) # 4
print(find_coins(13)) # [1, 2, 5, 5]
```

## Ratkaisujen laskeminen

Dynaamisen ohjelmoinnin avulla voidaan myös laskea, montako erilaista ratkaisua tehtävään on olemassa. Esimerkiksi kun $$x=13$$ ja kolikot ovat $$[1,2,5]$$, mahdollisia ratkaisuja on yhteensä $$634$$. Tässä on mukana kaikki mahdolliset tavat muodostaa summa $$13$$ käyttäen kolikkoja $$[1,2,5]$$. Tässä on joitakin mahdollisia tapoja:

* $$[1,2,5,5]$$ <span></span>
* $$[2,2,2,2,5]$$ <span></span>
* $$[1,1,1,5,5]$$ <span></span>
* $$[2,2,2,2,2,2,1]$$ <span></span>
* $$[1,1,1,1,1,1,1,1,1,1,1,1,1]$$ <span></span>

Kaikkien ratkaisujen määrä voidaan etsiä melko samalla tavalla kuin pienimmän ratkaisun kolikkojen määrä. Haku voidaan toteuttaa seuraavasti:

```python
coins = [1, 2, 5]
cache = {}

def count_coins(x):
    if x == 0:
        return 1

    if x < 0:
        return 0
        
    if x in cache:
        return cache[x]

    result = 0
    for coin in coins:
        result += count_coins(x - coin)
    cache[x] = result
    return result
```

Jos $$x=0$$, funktio palauttaa $$1$$, koska summa $$0$$ voidaan muodostaa yhdellä tavalla (ei mitään kolikkoja). Jos $$x<0$$, funktio palauttaa $$0$$, koska negatiivista summaa ei ole mahdollista muodostaa. Muuten funktio käy läpi kolikot ja laskee yhteen kaikki tavat, jotka saadaan valitsemalla jokin kolikoista ratkaisuun.

Funktiota voidaan käyttää näin:

```python
print(count_coins(13)) # 634
```

Huomaa, että funktio laskee erikseen kaikki tavat järjestää kolikot listaan. Esimerkiksi funktio laskee erikseen mukaan ratkaisut $$[1,2,5,5]$$, $$[1,5,2,5]$$ ja $$[1,5,5,2]$$, vaikka ne muodostuvat samoista kolikoista. Vaikeampi tehtävä, joka on myös mahdollista ratkaista dynaamisella ohjelmoinnilla, on laskea mukaan jokainen samojen kolikoiden yhdistelmä vain kerran.

## X

- rekursioraja
- memoize

## X

```python
def count_sequences(n):
    if n == 0:
        return 1
    result = 0
    for i in range(2, n, 2):
        result += count_sequences(i - 2) * count_sequences(n - i)
    return result
```
