---
title: 6. Omat tietorakenteet
slug: osa6
permalink: /:title/
---

# 6. Omat tietorakenteet

## Esimerkki: Pino

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Toteuta luokka `Stack`, joka toteuttaa pinotietorakenteen. Luokassa tulee olla seuraavat metodit:

* `push(x)`: lisää alkio `x` pinon ylimmäksi
* `top()`: hae pinon ylin alkio
* `pop()`: poista pinon ylin alkio

Jokaisen metodin aikavaativuuden tulee olla $$O(1)$$.

</div>

Luokka `Stack` on helppoa toteuttaa Pythonin listan avulla, koska alkion lisääminen listan loppuun ja poistaminen listan lopusta toimivat ajassa $$O(1)$$. Voimme toteuttaa luokan seuraavasti:

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, x):
        self.stack.append(x)

    def top(self):
        return self.stack[-1]

    def pop(self):
        self.stack.pop()
```

Ideana on, että luokan sisällä määritellään lista `stack`, johon tallennetaan pinon alkiot. Metodit `push` ja `pop` toteutetaan listan metodien `append` ja `pop` avulla ja metodi `top` toteutetaan hakemalla listan viimeinen alkio.

Seuraava koodi testaa luokan toimintaa:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.top()) # 3
print(s.top()) # 3
s.pop()
print(s.top()) # 2
```

Tässä tapauksessa luokka `Stack` rajoittaa listan toimintaa, koska luokan metodeilla on mahdollista käsitellä vain listan viimeistä alkiota. Luokan käyttäjän ei tarvitse tietää, miten luokka on toteutettu sisäisesti, vaan hän voi luottaa siihen, että saatavilla on metodit `push`, `top` ja `pop`.

Huomaa, että voimme kuitenkin käsitellä luokan sisäistä tietoa, jos tiedämme, miten luokka on toteutettu. Seuraava koodi havainnollistaa asiaa:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.stack) # [1, 2, 3]
```

## Älä tee luokkaa näin

Seuraava tapa luokan toteuttamiseen ei ole toimiva:

```python
class Stack:
    stack = []

    def push(self, x):
        self.stack.append(x)

    def top(self):
        return self.stack[-1]

    def pop(self):
        self.stack.pop()
```

Erona aiempaan luokkaan tässä luokassa ei ole alustusmetodia `__init__` vaan lista `stack` luodaan luokan päätasolla. Päältä päin luokka vaikuttaa toimivalta:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.top()) # 3
```

Ongelmana tässä toteutuksessa on kuitenkin, että lista `stack` on _yhteinen_ kaikille luokasta luoduille olioille. Seuraava koodi havainnollistaa ongelmaa:

```python
a = Stack()
b = Stack()
a.push(1)
b.push(2)
print(a.top()) # 2
```

Koodi lisää pinoon `a` luvun `1` ja pinoon `b` luvun `2`. Tämän jälkeen koodi hakee pinon `a` ylimmän alkion. Tuloksen pitäisi olla `1`, mutta se onkin `2`, koska pinoilla on yhteinen lista `stack`. Tämän seurauksena alkion lisääminen toiseen pinoon lisää sen kumpaankin pinoon eikä luokka toimi halutulla tavalla.

## Lisää ominaisuuksia luokkaan

Aiempi luokka `Stack` toimii sinänsä, mutta siinä on vielä joitakin puutteita. Ensinnäkään pinon sisällön tulostaminen ei anna hyödyllistä tietoa:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s) # <__main__.Stack object at 0x7fd6c4e23ee0>
```

Voimme korjata tämän lisäämällä luokkaan metodin `__repr__`, jonka tehtävänä on palauttaa tekstimuotoinen esitys luokan sisällöstä. Voimme toteuttaa metodin niin, että se palauttaa suoraan listan `stack` sisällön tekstinä:

```python
    def __repr__(self):
        return str(self.stack)
```

Tämän muutoksen jälkeen pinon sisältö tulostuu näin:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s) # [1, 2, 3]
```

Toinen puute on, että pinon kokoa ei pysty selvittämään funktiolla `len`, vaan tämä aiheuttaa virheilmoituksen. Voimme korjata tämän lisäämällä luokkaan seuraavan metodin `__len__`:

```python
    def __len__(self):
        return len(self.stack)
```

Metodia `__len__` kutsutaan silloin, kun luokasta tehty olio annetaan funktion `len` parametriksi. Tässä tapauksessa metodin riittää palauttaa listan `stack` koko. Nyt seuraava koodi toimii järkevällä tavalla:

```python
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(len(s)) # 3
```

Metodeissa `pop` ja `top` on vielä puutteena, että ne eivät ota huomioon tilannetta, jossa pino on tyhjä. Tässä tilanteessa ei ole mahdollista poistaa tai hakea pinon ylintä alkiota. Voimme lisätä metodeihin virheenkäsittelyn seuraavasti:

```python
    def pop(self):
        if len(self.stack) == 0:
            raise IndexError("pop from empty stack")
        return self.stack.pop()

    def top(self):
        if len(self.stack) == 0:
            raise IndexError("top from empty stack")
        return self.stack[-1]
```

Nyt jos metodeita kutsutaan pinon ollessa tyhjä, metodit tuottavat `IndexError`-virheen, jossa on tekstimuotoinen kuvaus virheen syystä. Seuraava koodi havainnollistaa asiaa:

```python
s = Stack()
s.push(1)
s.pop()
s.pop() # IndexError: pop from empty stack
```

## Esimerkki: 

{: .note-title }
Tehtävä
<div class="note" markdown="1">

Toteuta luokka `SuperStack`, jossa on seuraavat metodit:

* `push(x)`: lisää alkio `x` pinon ylimmäksi
* `push_many(x, k)`: lisää pinon ylimmäksi `k` kertaa alkio `x`
* `top()`: hae pinon ylin alkio
* `pop()`: poista pinon ylin alkio

Jokaisen metodin aikavaativuuden tulee olla $$O(1)$$.

</div>

Tämä luokka vasta muuten aiempaa luokkaa `Stack`, mutta siinä on uusi metodi `push_many`, jonka avulla voi lisätä saman alkion useita kertoja pinoon. Luokan toteutuksessa on haasteena, että myös metodin `push_many` tulee toimia ajassa $$O(1)$$ riippumatta siitä, miten monta kertaa alkio lisätään.

Seuraava tapa toteuttaa metodi `push_many` ei ole riittävä:

```python
    def push_many(self, x, k):
        for i in range(k):
            self.push(x)
```

Tässä ongelmana on, että funktiossa on silmukka, joka vie aikaa $$O(k)$$. Kuitenkin aikavaativuuden tulisi olla $$O(1)$$ eli funktiossa ei saa olla silmukkaa.
