---
title: 8. Verkkoalgoritmit
slug: osa8
permalink: /:title/
---

# 8. Verkkoalgoritmit

_Verkko_ (_graph_) on tietorakenne, joka muodostuu _solmuista_ (_node_) ja _kaarista_ (_edge_). Esimerkiksi seuraavassa verkossa on X solmua ja Y kaarta:

TODO

Verkkojen avulla voidaan mallintaa 

* tieverkko: solmut ovat kaupunkeja ja kaaret ovat teitä
* kontaktiverkko: solmut ovat ihmisiä ja kaaret ovat kontakteja
* tietoverkko: solmut ovat tietokoneita ja kaaret ovat yhteyksiä

## Verkot ohjelmoinnissa

Tavallinen tapa käsitellä verkkoa ohjelmoinnissa on pitää muistissa kunkin solmun _vieruslistaa_ (_adjacency list_). Solmun $$x$$ vieruslista sisältää kaikki solmut, jotka ovat yhteydessä solmuun $$x$$ kaarella.

Pythonissa voimme tallentaa verkon sanakirjana, jossa avaimet ovat solmuja ja arvot vieruslistoja. Esimerkkiverkko voidaan tallentaa seuraavasti:

```python
graph = {
    1: [2, 3, 4],
    2: [1, 4, 5],
    3: [1, 4],
    4: [1, 2, 3, 5],
    5: [2, 4]
}
```

Usein on kätevää tallentaa verkko luokan sisään niin, että verkossa on alussa vain solmut eikä kaaria. Luokassa on metodi, jonka avulla voidaan lisätä kaaria verkkoon. Luokka voidaan toteuttaa seuraavasti:

```python
class Graph:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}
        
    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)
```

Tässä konstruktorissa annetaan solmujen määrä `n`. Tämän perusteella luodaan sanakirja `edges`, joka sisältää vieruslistat. Aluksi jokainen vieruslista on tyhjä, ja metodi `add_edge` lisää kaaren solmujen `a` ja `b` välille.

Nyt voimme luoda esimerkkiverkon näin:

```python
g = Graph(5)

g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 4)
g.add_edge(2, 5)
g.add_edge(3, 4)
g.add_edge(4, 5)
```

## Syvyyshaku

_Syvyyshaku_ (_depth-first search_) eli _DFS_ on menetelmä, jonka avulla voidaan käydä läpi kaikki solmut, joihin pääsee lähtösolmusta kaaria pitkin.

```python
class Graph:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}
        
    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)
        
    def visit(self, node):
        if node in self.visited:
            return
        self.visited.add(node)

        for next_node in self.edges[node]:
            self.visit(next_node)
        
    def dfs(self, start_node):
        self.visited = set()
        self.visit(start_node)
```

```python
g = Graph(5)

g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 4)
g.add_edge(2, 5)
g.add_edge(3, 4)
g.add_edge(4, 5)

g.dfs(1)
print(g.visited) # {1, 2, 3, 4, 5}
```

## Leveyshaku

```python
class Graph:
    def __init__(self, n):
        self.n = n
        self.edges = {node: [] for node in range(1, self.n + 1)}

    def add_edge(self, a, b):
        self.edges[a].append(b)
        self.edges[b].append(a)

    def bfs(self, start_node):
        self.distances = {node: None for node in range(1, self.n + 1)}

        self.distances[start_node] = 0
        queue = [start_node]

        for node in queue:
            for next_node in self.edges[node]:
                if self.distances[next_node] is None:
                    self.distances[next_node] = self.distances[node] + 1
                    queue.append(next_node)
```

```python
g = Graph(5)

g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 4)
g.add_edge(2, 5)
g.add_edge(3, 4)
g.add_edge(4, 5)

g.bfs(1)
print(g.distances) # {1: 0, 2: 1, 3: 1, 4: 1, 5: 2}
```

## Labyrintti verkkona
